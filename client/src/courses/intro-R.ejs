<!DOCTYPE html>
<html lang="en-uk">

<head>
    <title>
        Dereck's Notes
    </title>
    <meta name="description"
    content="The online brain of Dereck de Mezquita; making sciencing easier.">
    <meta name="keywords"
        content="Science, Programming, Bioinformatics, Biology, Technology, Education, Art, Dictionary, Blog">
</head>

<body>
    <%- include ../templates/includes/info-bar.ejs %>
    <%- include ../templates/includes/header.ejs %>

    <%- include ../templates/includes/nav.ejs %>

    <div class="content-wrapper">
        <%- include ../templates/includes/side-bar.ejs %>

        <article>

<title>Introduction to R</title>
<h1>Introduction to R</h1>
<!-- UE102 Introduction to mathematics and computer science for biology -->
<div class="courseInfo">
    <div class="articleData">18 September 2019</div>
    <div class="articleData">Université Paris-Saclay</div>
    <!-- <div class="articleData">Anna Niaraki</div> -->
</div>
<p>
    R studio is an IDE for using R. It is nicer and we can use it to save our projects. R is case sensitive and space sensitive. It's variables can be modified after declaration. There are three types in R, character (strings), numeric (numbers), and logical (boolean).
</p>
<p>
    Always make sure to save your environements and scripts. 
</p>

<h2>Around R studio</h2>
<figure>
    <img class="lazy" data-src="/courses/documents/introR/rstudio.png">
    <figcaption>What R studio looks like when first opened.</figcaption>
</figure>
<p>
    When you first open R studio, you will see three panes. These are in clockwise order data objects, file/plots/packages/help, and finally the console. The console is temporary and will eventually clear.
</p>

<figure>
    <img class="lazy" data-src="/courses/documents/introR/rscript.gif">
    <figcaption></figcaption>
</figure>
<p>
    To open the script pane, click the plus button at the top left. This script pane is where we make our actual projects. These can be saved, and rerun later on.
</p>
<p>
    You can use as many packages as you want. But be careful about finding quality packages. This is because R evolves as a language over time, and some can become outdated. However it is possible to use other versions of R to run outdated programmes or packages.
</p>

<h3>Basic commands</h3>
<p>
    Let's start by finding the working directory, or the current directory.
</p>
<pre class="brush: r">
    > getwd()
</pre>
<p>
    This command will get the current directory.
</p>

<figure>
    <img class="lazy" data-src="/courses/documents/introR/setwd.png">
    <figcaption>Setting the working directory.</figcaption>
</figure>
<p>
    To change working directory we can do it with a command, or with a button from the GUI.
</p>
<pre class="brush: r">
    > setwd("~/Coding/r-studio")
</pre>

<figure>
    <img class="lazy" data-src="/courses/documents/introR/packages.png">
    <figcaption>Installing packages through the GUI.</figcaption>
</figure>
<p>
    Packages, if everything is working properlly, you can go through the GUI. If things don't work try the console, it is much more powerful.
</p>

<h2>The basics of R</h2>
<p>
    Here will we go through the theory of the tool and what it does. Note that the R vs Matlab war is moot. We do not use R because it is free but because it is powerful and the appropriate tool.
</p>

<h3>What is R?</h3>
<p>
    A language for statistical analysis. Is it a true programming langauge? It does not matter, it is Turing complete full stop. It is useful it does not matter.
</p>
<p>
    The advantages of using R: it's open source and free, it's powerful at producing images and graphics, it has a command line interface, has reproducibility through R scripts, can use packages/extensions, and has a vibriant community.
</p>
<p>
    The disadvanges are: easy to learn but hard to master, the command line interface can be scary at first, poorly written code is hard to maintain and read, finally poorly written code will run slowly.
</p>

<h2>The console</h2>
<p>
    In reality the console is all that one needs. It can be used to do very simple things, for example: <code>1 + 2</code>.
</p>
<p>
    <pre class="brush: r">
        > 1 + 2
        [1] 3
    </pre>
</p>

<h3>Create a variable</h3>
<p>
    This is done with the <code>&lt;-</code> or <code>=</code> to designate equals. It seems that all variables in R are also by default a vector (array) this can be tested with <code>is.vector()</code>.
</p>
<pre class="brush: r">
    > height = 2
    > height
    [1] 2
</pre>

<h3>Create random data</h3>
<p>
    Producing random values or pseudorandom. To do this use the <code>sample()</code> function.
</p>
<pre class="brush: r">
    > randommatrix = matrix(sample(1:15, 12), nrow = 3)
    > randommatrix
        [,1] [,2] [,3] [,4]
    [1,]   10   13   12   11
    [2,]    2   15    9    7
    [3,]    4    5    6   14
</pre>

<h3>Getting all created objects</h3>
<p>
    This will be useful when creating multiple objects and for listing them.
</p>
<pre class="brush: r">
    > ls()
    [1] "height"
</pre>

<h3>My first R script</h3>
<pre class="brush: r">
    height = 42
    width = 53
    depth = 12
    volume = height * width * depth
    volume
    
    # This is a comment
</pre>

<h3>Remove a variable</h3>
<p>
    To remove a variable use the remove command: <code>rm()</code>.
</p>

<h2>Basic data types</h2>
<p>
    Data types are different kinds of data, or variables that can be used in R. We can create different objects depending on the things we want to analyse.
</p>
<p>
    In order to get the type of a variable use the <code>class()</code> command.
</p>
<p>
    We can also use <code>is.numeric</code> type of syntax.
</p>
<pre class="brush: r">
    > is.integer(testNumber)
    [1] TRUE
</pre>

<h3>Logical variables (blooleans)</h3>
<p>
    For booleans, <code>TRUE</code> or <code>FALSE</code> we use the aforementioned syntax. Abbreviations can be used for these as well, <code>T</code>, and <code>F</code>.
</p>

<h3>Numeric variables</h3>
<p>
    We can use whole numbers, or integers, as well as decimals. In order to set the type of a variable to an integer we use the <code>L</code> syntax.
</p>
<pre class="brush: r">
    > testNumber = 2L
    > class(testNumber)
    [1] "integer"    
</pre>

<h2>Create and name vectors (arrays)</h2>
<p>
    Vectors is a sequence of data elements. You put in a vector things that are of the same type, this is the equivalent to an array in JavaScript.
</p>
<p>
    To create a vector use the following syntax:
</p>
<pre class="brush: r">
    > c("hearts", "spades", "diamonds", "spades")

    # In order to set the vector to a variable:
    > testvector = c("hearts", "spades", "diamonds", "spades")
    is.vector(testvector)
    [1] TRUE
</pre>

<div class="courseInfo">
    <div class="articleData">19 September 2019</div>
    <div class="articleData">Université Paris-Saclay</div>
    <!-- <div class="articleData">Anna Niaraki</div> -->
</div>

<p>
    We can make numeric and character vectors. Let's make a couple more for fun.
</p>
<pre class="brush: r">
    > ages = c(27, 24, 21, 49, 53)
    > 
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > 
    > numvec
    [1] 223 134  53 293  93  10  21
    > charvec
    [1] "spades"   "diamonds" "clubs"    "spades"   
</pre>

<h3>Naming vectors</h3>
<p>
    We can combine two vectors, for example giving values of a vector names by a second vector's values. To do this through the syntax of the language when you already have two vectors you do it the following way.
</p>
<pre class="brush: r">
    ages = c(27, 24, 21, 49, 53)

    names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    
    names(ages) = names
    ages

    # Console gives

    > ages = c(27, 24, 21, 49, 53)
    > 
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > 
    > names(ages) = names
    > ages
    Dereck Priscilla     Edson      Mami      Papi 
        27        24        21        49        53 
</pre>

<div class="warning">
    Pay attention to the order inside of the vectors when assigning a vector to another.
</div>
<p>
    Otherwise you can set the values equal to names or inversely when first creating a vector, as so.
</p>

<pre class="brush: r">
    namesAges = c("Dereck" = 27, "Priscilla" = 24, "Edson" = 21, "Mami" = 49, "Papi" = 53)

    namesAgesTwo = c(Dereck = 27, Priscilla = 24, Edson = 21, Mami = 49, Papi = 53)
    
    namesAges
    namesAgesTwo

    # Console gives

    > namesAges = c("Dereck" = 27, "Priscilla" = 24, "Edson" = 21, "Mami" = 49, "Papi" = 53)
    > 
    > namesAgesTwo = c(Dereck = 27, Priscilla = 24, Edson = 21, Mami = 49, Papi = 53)
    > 
    > namesAges
    Dereck Priscilla     Edson      Mami      Papi 
        27        24        21        49        53 
    > namesAgesTwo
    Dereck Priscilla     Edson      Mami      Papi 
        27        24        21        49        53 
</pre>

<h3>Testing the structure of a vector</h3>
<p>
    After having done this we can sometimes forget the structure, what we've done to the vector. If it has names or not etc. So this can be tested with the structure command: <code>str()</code>. The same as the <code>class()</code> command it will give back this information in the console.
</p>
<pre class="brush: r">
    > str(namesAges)
    Named num [1:5] 27 24 21 49 53
    - attr(*, "names")= chr [1:5] "Dereck" "Priscilla" "Edson" "Mami" ...
</pre>

<h3>Single value vector</h3>
<p>
    We can have vectors that have only one value. This can be done in the following way.
</p>
<pre class="brush: r">
    > testvar = "Yeet"
    > is.vector(testvar)
    [1] TRUE
</pre>

<h3>Vectors are homogeneous</h3>
<p>
    Only elements of the same type can be in a single vector.
</p>
<pre class="brush: r">
    > mixvector = c("one", 2, "three", 4, "five")
    > class(mixvector)
    [1] "character"
    > str(mixvector)
        chr [1:5] "one" "2" "three" "4" "five"
    > is.vector(mixvector)
    [1] TRUE
</pre>

<p>
    Note that the type coerion occurs, this means that the numbers are now treated like characters. We lose the mathematical properties of our numbers, this means that we cannot multiply, add etc. If we want to mix these types of variables then we can use lists instead, or mix two vectors by assigning names as we did before.
</p>
<div class="warning">
    Avoid mixing types in vectors so that you keep the properties of the numbers.
</div>

<h3>Vector calculus</h3>
<p>
    Calculations are performed element wise. This means that when you multiply a vector by a value it will multiply each value of the vector individually to the given value.
</p>

<pre class="brush: r">
    > ages = c(27, 24, 21, 49, 53)
    > ages * 3
    [1]  81  72  63 147 159
</pre>
<p>
    We can also do this same process on two vectors and elements will be calculated against each other as per the element index.
</p>
<pre class="brush: r">
    > ages
    [1] 27 24 21 49 53
    > rndmvalue = c(1, 2, 3, 4, 5)
    > ages + rndmvalue
    [1] 28 26 24 53 58
</pre>
<p>
    Let's see what happens when one is longer than the other.
</p>
<pre class="brush: r">

    > ages
    [1] 27 24 21 49 53
    > rndmvalue = c(1, 2, 3, 4, 5, 10, 2, 2)
    > ages + rndmvalue
    [1] 28 26 24 53 58 37 26 23
    Warning message:
    In ages + rndmvalue :
    longer object length is not a multiple of shorter object length
</pre>
<p>
    Oops we get an error, this operation is not possible.
</p>

<h2>Subsetting vectors</h2>
<p>
    Sometimes in a vector we don't need all the values. This means to isolate a certain amount of elements from a vector and assign it to a new vector. For this we use the name of the vector with brackets <code>vector[]</code>. If we set a variable equal to this we get back a new vector with the element of the indicated index.
</p>
<pre class="brush: r">
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > subsetvec = names[2]
    > subsetvec
    [1] "Priscilla"
</pre>
<p>
    To do multiple elements we do put a vector in the square brackets, we can nest a function inside another; commas will not work.
</p>
<pre class="brush: r">
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > subsubvec = names[c(1, 3, 5)]
    > subsubvec
    [1] "Dereck" "Edson"  "Papi" 
</pre>
<div class="note">
    Protip: this method will allow us to even change the order of the original vector.
</div>

<h3>Subsetting all but some</h3>
<p>
    So let's say we want the whole of one vector, but we don't want some values. The way to do this is by using negative index.
</p>

<pre class="brush: r">
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > negsubvec = names[-2]
    > negsubvec
    [1] "Dereck" "Edson"  "Mami"   "Papi"  
</pre>

<p>
    Now for removing multiple items we use the same logic as before, that is a negative vector.
</p>

<pre class="brush: r">
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > negativesubvec = names[c(-1, -5)]
    > negativesubvec
    [1] "Priscilla" "Edson"     "Mami" 
</pre>

<h3>Subsetting logical vectors</h3>
<p>
    We can even do it with logicial vectors.
</p>
<pre class="brush: r">
    > booleanvec = c(TRUE, FALSE, TRUE, TRUE, FALSE)
    > remainbool = booleanvec[c(FALSE, TRUE, TRUE)]
    > remainbool
    [1] FALSE  TRUE FALSE
</pre>

<p>
    Remember the thing we did when naming a vector's values? We can do a similar thing with logical values. Careful because R will recycle if the lengths of the vectors are not the same. This means that it will repeat based on the pattern given to the end of the elements to which we want to assing the logical values.
</p>
<pre class="brush: r">
    > names = c("Dereck", "Priscilla", "Edson", "Mami", "Papi")
    > logicalnames = names[c(T, F, F, F, T)]
    > logicalnames
    [1] "Dereck" "Papi"  
</pre>

<div class="note">
    Note that when printing on those which we assigned the TRUE value were printed.
</div>

<h2>Matrices</h2>
<p>
    In order to create matrices we use the <code>matrix()</code>. Note that matrices are two dimensional, thus we need to specify the number of rows, and the number of columns are calculated automatically.
</p>
<div class="note">
    Matrices are column wise by default.
</div>

<pre class="brush: r">
    > matrix(1:6, nrow = 2)
    [,1] [,2] [,3]
    [1,]    1    3    5
    [2,]    2    4    6
    > 
    > matrix(1:6, ncol = 3)
            [,1] [,2] [,3]
    [1,]    1    3    5
    [2,]    2    4    6
    > 
    > matrix(1:6, nrow = 2, byrow = TRUE)
            [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    4    5    6
</pre>

<p>
    Let's create something for practice, 12 elements, 4 columns and order to be column wise.
</p>
<pre class="brush: r">
    > matrix(1:12, ncol = 4)
    [,1] [,2] [,3] [,4]
    [1,]    1    4    7   10
    [2,]    2    5    8   11
    [3,]    3    6    9   12
</pre>

<h3>Matrix recycling function</h3>
<p>
    The same thing can be done in matrices, that is 
</p>
<pre class="brush: r">
    > matrix(1:3, nrow = 2, ncol = 3)
    [,1] [,2] [,3]
    [1,]    1    3    2
    [2,]    2    1    3
    > 
    > matrix(1:4, nrow = 2, ncol = 3)
            [,1] [,2] [,3]
    [1,]    1    3    1
    [2,]    2    4    2
    Warning message:
    In matrix(1:4, nrow = 2, ncol = 3) :
        data length [4] is not a sub-multiple or multiple of the number of columns [3]
</pre>
<p>
    We will not get exactly what we wanted, that is it will recycle to fill the spots.
</p>
<h4>rbind(), cbind()</h4>
<p>
    This allows us to bind either columns or rows.
</p>
<pre class="brush: r">
    > bindone = cbind(1:3, 1:3)
    > bindone
            [,1] [,2]
    [1,]    1    1
    [2,]    2    2
    [3,]    3    3
    > bindtwo = rbind(1:3, 1:3)
    > bindtwo
            [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    1    2    3
    > str(bindone)
        int [1:3, 1:2] 1 2 3 1 2 3
    > class(bindone)
    [1] "matrix"
    > str(bindtwo)
        int [1:2, 1:3] 1 1 2 2 3 3
    > class(bindtwo)
    [1] "matrix"
</pre>

<h5>Adding columns and rows to an existing matrix</h5>
<p>
    This can be done  by using the same <code>rbind()</code> and <code>cbind()</code> commands, just giving different arguments.
</p>
<pre class="brush: r">
    > newmatrix = matrix(1:6, byrow = TRUE, nrow = 2)
    > 
    > # Let's add another row and column
    > 
    > rbind(newmatrix, 7:9)
        [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    4    5    6
    [3,]    7    8    9
    > cbind(newmatrix, c(10, 11))
        [,1] [,2] [,3] [,4]
    [1,]    1    2    3   10
    [2,]    4    5    6   11
</pre>

<h3>Naming a matrix</h3>
<p>
    This will allow us to name different parts with names using characters. For example naming a row and a column. Be careful to name all of the rows/columns otherwise we get an error; recycling is not always applied.
</p>
<pre class="brush: r">
    > newmatrix = matrix(1:6, byrow = TRUE, nrow = 2)
    > newmatrix
        [,1] [,2] [,3]
    [1,]    1    2    3
    [2,]    4    5    6
    > rownames(newmatrix) = c("row1", "row2")
    > newmatrix
        [,1] [,2] [,3]
    row1    1    2    3
    row2    4    5    6
    > rownames(newmatrix)
    [1] "row1" "row2"
</pre>
<p>
    Another way to do this would be to name the parts while creating the matrix. This is done like so.
</p>
<pre class="brush: r">
    > newmatrix = matrix(1:6, byrow = TRUE, nrow = 2,
    +                    dimnames = list(c("row1", "row2"),
    +                                    c("col1", "col2", "col3")))
    > 
    > newmatrix
            col1 col2 col3
    row1    1    2    3
    row2    4    5    6
</pre>
<p>
    This is done through the <code>dimnames</code> command, and using a list with different vectors for the different parts; rows/columns.
</p>

<h3>Coercion in matrices</h3>
<p>
    Coercion can also be done in matrices.
</p>
<pre class="brush: r">
    > num = matrix(1:8, ncol = 2)
    > num
        [,1] [,2]
    [1,]    1    5
    [2,]    2    6
    [3,]    3    7
    [4,]    4    8
    > 
    > char = matrix(LETTERS[1:6], nrow = 4, ncol = 3)
    > char
        [,1] [,2] [,3]
    [1,] "A"  "E"  "C" 
    [2,] "B"  "F"  "D" 
    [3,] "C"  "A"  "E" 
    [4,] "D"  "B"  "F" 
    > 
    > cbind(num, char)
        [,1] [,2] [,3] [,4] [,5]
    [1,] "1"  "5"  "A"  "E"  "C" 
    [2,] "2"  "6"  "B"  "F"  "D" 
    [3,] "3"  "7"  "C"  "A"  "E" 
    [4,] "4"  "8"  "D"  "B"  "F" 
</pre>
<p>
    Notice that the numbers were all forced into character types. Be careful when wanting to combine different matrices of different data types.
</p>

<h2>Factors</h2>
<p>
    Limited number of different values, and belong to a category. There are a limited number of them, like stage 1 - 3 cancer.
</p>

<h3>Create a factor</h3>
<p>
    For this we will use the <code>factor()</code> function. Levels are useful for giving values to a vector of characters, unique strings. This means that those that appear multiple times take the same value; categories are created with explicit values. These values are attributed by alphabetical order if you do not specify 
</p>
<pre class="brush: r">
    > blood = c("B", "AB", "O", "A", "O", "O", "A", "B")
    > blood
    [1] "B"  "AB" "O"  "A"  "O"  "O"  "A"  "B" 
    > 
    > bloodFactor = factor(blood)
    > bloodFactor
    [1] B  AB O  A  O  O  A  B 
    Levels: A AB B O
    > 
    > str(bloodFactor)
        Factor w/ 4 levels "A","AB","B","O": 3 2 4 1 4 4 1 3
</pre>
<h3>Levels of a factor</h3>
<p>
    When you use the <code>str()</code> function you get back the levels of the factor. 
</p>

<p>
    T-shirt sizes is another way of understanding levels. Of course S is smaller than L, but R doesn't know this so we tell it in the following way. This is how we tell it what levels are defined. The <code>ORDERED</code> argument is ascending.
</p>

<pre class="brush: r">
    > tshirt = c("M", "L", "S", "S", "L", "M", "L", "M")
    > 
    > tshirtFactor = factor(tshirt, ordered = TRUE,
    +                       levels = c("S", "M", "L"))
    > 
    > tshirtFactor
    [1] M L S S L M L M
    Levels: S < M < L
</pre>

<h2>Create and name lists</h2>
<div class="courseInfo">
    <div class="articleData">23 September 2019</div>
    <div class="articleData">Université Paris-Saclay</div>
    <!-- <div class="articleData">Anna Niaraki</div> -->
</div>
<p>
    This is one of the last things we need to learn to undertand data frames. Complexity goes from vectors to matrix to lists. Lists allow us to store different objects of different types without coercion. However there is the loss of some functionality. It's like a messy closet where things are thrown in. 
</p>
<p>
    To create a list use the <code>list()</code> command. To create a list though there are a couple of steps. Of course the vector will be coerced. Lists are hierarchical objects.
</p>
<pre class="brush: r">
    > list("Rsome times", 190, 5)
    [[1]]
    [1] "Rsome times"
    
    [[2]]
    [1] 190
    
    [[3]]
    [1] 5

    > song = list("Rsome times", 190, 5)
    > is.list(song)
    [1] TRUE
</pre>

<p>
    You can also name lists with the command <code>names()</code> the same way we named matrices.
</p>

<pre class="brush: r">
    > names(song) = c("title", "duration", "track")
    > song
    $title
    [1] "Rsome times"
    
    $duration
    [1] 190
    
    $track
    [1] 5
</pre>

<div class="note">
    Reminder to get help on a function use: <code>?list()</code>
</div>

<h3>List in list</h3>


<h2>Explore the data frame</h2>
<p>
    
</p>
<!-- <div class="courseInfo">
    <div class="articleData">24 September 2019</div>
    <div class="articleData">Université Paris-Saclay</div>
    <div class="articleData">Absent this day; RER not working.</div>
    <div class="articleData">Anna Niaraki</div>
</div> -->

<h2>Statistics and R</h2>

<div class="courseInfo">
    <div class="articleData">25 September 2019</div>
    <div class="articleData">Université Paris-Saclay</div>
    <!-- <div class="articleData">Anna Niaraki</div> -->
</div>
<h3>Normal distribution</h3>
<p>
    All about obtaining good samples, it is unimodal and symetric, many variables are nearly normal but none are exactly normale. Denoted N(&mu;, &sigma;).
</p>






<ol class="foot-notes">
    <div class="foot-notes-head">
        Footnotes:
    </div>
    <li>
        Basic commands: to remove variables <code>rm</code>, to get a list of all variables <code>ls</code>.
    </li>
    <li>
        For help type <code>?function()</code> into the console and the right window on the bottom will help you with information on the function.
    </li>
    <!-- <li>
        No evaluation for this course, not obligatory.
    </li> -->
</ol>

<script type="text/javascript">
    SyntaxHighlighter.all()
</script>
        </article>
    </div>

    <%- include ../templates/includes/footer.ejs %>
</body>

</html>
