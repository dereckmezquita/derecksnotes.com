---
title: "Introduction to Statistics with R"
subtitle: "Foundations: Data Structures and Core Workflows"
blurb: "File war tea"
coverImage: 13
author: "Dereck Mezquita"
date: 2023-10-20
tags: [statistics, mathematics, probability, data]
published: true
comments: true
output:
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
# https://bookdown.org/yihui/rmarkdown-cookbook/hook-html5.html
if (knitr::is_html_output()) knitr::knit_hooks$set(
    plot = function(x, options) {
        cap  <- options$fig.cap
        # x <- paste0("/courses/", x)
        as.character(htmltools::tag(
            "Figure", list(src = x, alt = cap, paste("\n\t", cap, "\n", sep = ""))
        ))
    }
)

knitr::knit_hooks$set(optipng = knitr::hook_optipng) # optipng = '-o7'
knitr::opts_chunk$set(dpi = 300, fig.width = 10, fig.height = 7)
```

### Chapter 6: Data Visualisation with ggplot2

#### 6.1 Understanding the Grammar of Graphics

*Visualising data is more than just plotting points or drawing bars: it is about telling a story through images, crafting a visual narrative that illuminates hidden patterns, relationships, and structures. The **grammar of graphics** provides a systematic, coherent framework for thinking about and building these visual stories. Instead of memorising a list of specialised plot types, the grammar of graphics allows you to construct almost any visualisation by combining fundamental components—data, aesthetic mappings, geometric objects, statistical transformations, coordinates, and facets.*

*Imagine you’re an architect: you have fundamental building blocks (walls, windows, doors) and rules for how they fit together. The grammar of graphics is like a blueprint that guides you in assembling these components to create your ideal “visual building.” The `ggplot2::` package, built upon this grammar, gives you tools to layer these components step by step, resulting in flexible, expressive, and beautiful visualisations.*

---

#### Principles of the Grammar of Graphics

1. **Data**:  
   At the core of any plot is your dataset. You start with a `data.table::` and choose the variables you want to visualise. For example, if you have a dataset of flower measurements, you decide which variables (like `Sepal.Length` and `Petal.Width`) to present.

2. **Aesthetics (aes)**:  
   Aesthetics define how data variables map to visual properties such as position (x and y), colour, shape, and size. For instance, you might map `Sepal.Length` to the x-axis, `Petal.Width` to the y-axis, and perhaps `Species` to the colour of points.

3. **Geometric Objects (geoms)**:  
   Geoms specify the type of plot element to draw. Points for scatterplots, lines for time series, bars for bar charts, and so on. Each geom knows how to translate data and aesthetics into a visual mark on the plot. For example, `geom_point()` places points at coordinates defined by your data’s aesthetics.

4. **Statistical Transformations (stats)**:  
   Sometimes you don’t want to plot raw data. You might want aggregates (like means, medians), smooth curves, or binning for histograms. Stats handle these transformations. For example, `geom_smooth()` applies a smoothing statistic to fit a line, while `geom_bar()` counts data within categories.

5. **Coordinates and Scales**:  
   Coordinates define the space in which your data are drawn—Cartesian by default, but you can use polar or logarithmic scales. Scales control how data values map to aesthetic values (e.g., what range the x-axis covers, how colours map to categories, etc.).

6. **Faceting**:  
   Facets let you split data into multiple subplots by the values of one or more variables. If you want to compare distributions across different species or different time periods, faceting creates a grid of plots, each showing a subset of the data.

*By mixing and matching these components, you create a layered approach to building plots. Each layer adds something: a new geom, a different scale, a facet. You start with a blank canvas and paint your story one layer at a time.*

---

#### A Step-by-Step Example

*We’ll use the `iris` dataset, a classic built-in dataset containing measurements of iris flowers. We’ve used it before, and it’s conveniently accessible.*

\\`\\`\\`r
# Load the iris dataset into a data.table
iris_data <- data.table::as.data.table(datasets::iris)
print(head(iris_data))
\\`\\`\\`

*Now, let’s build a scatterplot showing `Sepal.Length` vs `Petal.Length`. To illustrate the grammar of graphics concept, we’ll start simple and then add layers:*

1. **Start with Data and Aesthetics**:  
   The foundation of the plot is specifying the data and how variables map to x and y coordinates.

   \\`\\`\\`r
   ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length))
   \\`\\`\\`

   This command sets the stage: we have data and we know what goes on x and y. But nothing is drawn yet because we haven’t chosen a geom.

2. **Add a Geom**:  
   We want a scatterplot, so we add points. The `+` operator adds a layer.

   \\`\\`\\`r
   ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length)) +
     ggplot2::geom_point()
   \\`\\`\\`

   Now we see a scatter of points. This is our first visual. But we can do more.

3. **Add Colour by Species (More Aesthetics)**:  
   We can distinguish species by colour, making it easier to see patterns by category.

   \\`\\`\\`r
   ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
     ggplot2::geom_point() +
     ggplot2::labs(
       title = "Sepal vs Petal Length by Species",
       x = "Sepal Length (cm)",
       y = "Petal Length (cm)"
     )
   \\`\\`\\`

   Now each species is coloured differently, providing an immediate visual cue.

4. **Add a Smoothing Line (Stats)**:  
   Suppose we want to see if there’s a trend. Add a smoothing line to hint at the relationship.

   \\`\\`\\`r
   ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
     ggplot2::geom_point() +
     ggplot2::geom_smooth(se = FALSE) +
     ggplot2::labs(
       title = "Sepal vs Petal Length by Species",
       x = "Sepal Length (cm)",
       y = "Petal Length (cm)"
     )
   \\`\\`\\`

   `geom_smooth()` uses a default statistical transformation (loess smoothing) to draw a fitted curve. This shows that relationships differ by species.

---

#### The Power of the Grammar

*Unlike systems where you choose from a fixed menu of plot types, the grammar of graphics lets you “invent” your plot by layering components. If you need a jittered scatterplot over a boxplot, or a density contour on top of points, it’s all just adding another geom layer.*

- **No Limits**: If you can imagine a visual relationship, you can likely build it by combining the appropriate geoms, aesthetics, stats, and facets.

- **Mathematical Foundations**: The grammar is grounded in concepts of mapping from data space to aesthetic space. For continuous variables, $$x$$ and $$y$$ represent coordinates; for categorical variables, levels might determine discrete positions or colours. Stats operate on the data: for example, smoothing involves fitting a function $$\hat{y}(x)$$ to approximate the relationship.

---

#### Another Example: Histograms

*The grammar is not limited to scatterplots. Suppose you want a histogram of `Sepal.Length`:*

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length)) +
  ggplot2::geom_histogram(binwidth = 0.3, fill = "lightblue", colour = "black") +
  ggplot2::labs(
    title = "Histogram of Sepal Length",
    x = "Sepal Length (cm)",
    y = "Count"
  )
\\`\\`\\`

*Here, `geom_histogram()` applies a statistical transformation that bins the data and counts occurrences in each bin, then draws bars. Again, data, aesthetics, and geoms combine into a coherent plot.*

---

#### Domain Expertise and Customisation

*As you progress, you’ll customise plots by adjusting scales (log scales for skewed data), coordinate systems (polar coordinates for circular data), or add facets to split data by categories. Domain knowledge guides these choices: If you know certain variables span multiple orders of magnitude, a log scale might clarify patterns.*

---

#### Real-World Implications

*In a complex dataset—say, economic indicators across countries and years—the grammar of graphics allows you to:
- Plot GDP vs life expectancy with points,  
- Colour points by continent,  
- Add smoothing lines to see trends over time,  
- Facet by year to see how patterns evolve.*

*This single cohesive framework lets you go from raw data to an insightful multi-dimensional plot without switching plotting paradigms.*

---

#### Next Steps

*Understanding the grammar of graphics sets a foundation for the upcoming sections:
- Learning about core geometric objects (bars, lines, densities),
- Managing scales and coordinates for nuanced control,
- Faceting your data to break down complexity.*

*As you gain confidence, you’ll build richer, more sophisticated plots and use them to communicate your findings effectively. The grammar of graphics is not just a plotting tool; it’s a language for visual thinking.*

[^1]: The concept of the grammar of graphics was introduced by Leland Wilkinson. ggplot2, created by Hadley Wickham, implements these ideas in R, enabling a powerful, layered approach to data visualisation.  


### Chapter 6: Data Visualisation with ggplot2

#### 6.2 Core Geometric Objects and Aesthetics

*Building upon the grammar of graphics concept, the next layer of detail focuses on the heart of any ggplot2 visualisation: the geometric objects (geoms) and the aesthetics (aes). These are the fundamental building blocks that transform raw data into expressive visuals. Understanding them deeply allows you to construct a wide range of plots, from simple scatterplots to complex layered graphics.*

*Imagine you’re a painter with a palette of shapes: points, lines, bars, polygons. These shapes are your geoms. Your variables, mapped onto positions, colours, and sizes, are your aesthetics. By combining geoms and aesthetics, you paint a meaningful picture of your data. This approach empowers you to reveal patterns, highlight differences, and convey insights that raw numbers cannot.*

---

#### What Are Geometric Objects (Geoms)?

- **Definition**: A geom is a specific type of mark drawn on the plot to represent data points. Examples include:
  - \*Points (geom_point)\*: Perfect for scatterplots and highlighting individual observations.
  - \*Lines (geom_line)\*: Ideal for time series, trends, and paths.
  - \*Bars (geom_bar)\*: Great for categorical summaries, frequencies, or aggregates.
  - \*Boxplots (geom_boxplot)\*: Summarise distributions with medians, quartiles, and outliers.
  - \*Histograms (geom_histogram)\* and \*Density plots (geom_density)\*: Reveal distributions of a single numeric variable.

*Each geom corresponds to a different way of representing data, much like each brush or pen stroke creates a different texture or shape on a canvas.*

---

#### What Are Aesthetics (aes)?

- **Definition**: Aesthetics describe how data variables map to visual properties of geoms. Common aesthetics include:
  - \*x\* and \*y\*: Positions on the horizontal and vertical axes.
  - \*colour\*: The outline or stroke colour of shapes or lines.
  - \*fill\*: The interior colour of shapes like bars or polygons.
  - \*size\*: The size of points or thickness of lines.
  - \*shape\*: The symbol used for points.
  - \*alpha\*: Transparency level, useful to handle overplotting.

*Think of aesthetics as a language that translates numbers into visual cues. Without aesthetics, you’d have no way to position points or distinguish groups by colour. Aesthetics give meaning and structure, turning raw measurements into a meaningful image.*

---

#### Demonstration with Real Data

*Let’s work with the `iris` dataset again. We know it contains measurements of iris flowers: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, and Species. We can easily load it into a data.table.*[^1]

\\`\\`\\`r
iris_data <- data.table::as.data.table(datasets::iris)
print(head(iris_data))
\\`\\`\\`

*Suppose we want to create a scatterplot of Sepal.Length vs Petal.Length. We need a geom and some aesthetics:*

1. **Map Data to Aesthetics**:  
   We map `Sepal.Length` to x, `Petal.Length` to y, and `Species` to colour for added distinction.

2. **Choose a Geom**:  
   We’ll use points (geom_point) to represent individual flowers.

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point() +
  ggplot2::labs(
    title = "Iris Sepal vs Petal Length",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

*This code creates a scatterplot where each point’s position is determined by Sepal and Petal lengths, and the point’s colour indicates its species. By layering `geom_point()` on top of the ggplot, we have constructed a meaningful visual that reveals species differences.*

---

#### Experimenting with Different Geoms

*What if we wanted to summarise data by species using a bar chart? For categorical data, `geom_bar()` is handy. Suppose we count how many observations per species we have.*

*The iris dataset has equal counts per species, but let’s still demonstrate:*

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Species)) +
  ggplot2::geom_bar(fill = "lightblue", colour = "black") +
  ggplot2::labs(
    title = "Count of Iris Species",
    x = "Species",
    y = "Count"
  )
\\`\\`\\`

*Here, x = Species maps the categorical species to the x-axis. `geom_bar()` by default counts how many rows fall into each category. No y aesthetic needed; the stat automatically computes counts. The chosen geom (bar) pairs naturally with the categorical aesthetic mapping to produce a frequency bar chart.*

---

#### Adjusting Aesthetics

*Want to differentiate points further? You can map another variable to shape, or control transparency with alpha to handle overplotting. For instance, if we think `Sepal.Width` might add another dimension, we can try mapping it to size:*

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species, size = Sepal.Width)) +
  ggplot2::geom_point(alpha = 0.7) +
  ggplot2::labs(
    title = "Iris Scatterplot with Size Mapped to Sepal Width",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

*Now bigger points represent flowers with wider sepals. Through aesthetics, you’ve integrated more data dimensions into a single plot, making it richer and more informative.*

---

#### Mathematical Connections

*Each aesthetic mapping corresponds to a function from your data to a visual scale. For example, mapping Sepal.Length to the x-axis is essentially a function \( x = f(\text{Sepal.Length}) \). If the data is normalised or scaled, you might have a linear transformation \( x = a \cdot (\text{Sepal.Length}) + b \).*

*For colour and size, think of them as mappings from numerical or categorical values to a colour space or a size scale. If Petal.Width is numeric, mapping it to size means defining a scale function \( \text{size}( \text{Petal.Width} ) \) that assigns larger sizes to larger values. These mappings help reveal underlying patterns in a way our eyes and brain can intuitively comprehend.*

---

#### Practical Tips

- **Choose Geoms That Fit Your Data**: Points for raw data, bars for categories, lines for trends, boxplots for distributions.
- **Start Simple, Then Layer More Aesthetics**: Begin with just x and y. Add colour or size mapping later if needed. Too many aesthetics can overwhelm the viewer.
- **Customise Parameters**: `geom_point(size=3)` or `geom_bar(width=0.8)` let you refine visuals for clarity.
- **Combine Multiple Geoms**: Add a smoothing line (`geom_smooth()`) to a scatterplot or overlays like text labels or contours to enrich the narrative.

---

#### Real-World Example

*Suppose you have a dataset of car attributes: horsepower, weight, mpg, and cylinder count. You might:
- Use `geom_point()` to plot mpg vs horsepower.
- Colour points by cylinder count.
- Adjust point size by weight.
  
In one plot, you’ll see how engine power relates to efficiency, how that differs by engine type (cylinders), and how heavier cars distribute in the mix. You can spot clusters, outliers, and relationships at a glance.*

---

#### The Gateway to Complexity

*Understanding geoms and aesthetics is just the beginning. Upcoming sections explore how to refine scales, choose coordinate systems, facet data, and polish themes. But these core concepts—geoms as shapes, aesthetics as mappings—are the foundation. Once you master them, you can create virtually any type of plot you imagine.*

*Embrace experimentation: try different geoms, add aesthetics, see what patterns emerge. This process transforms raw data into visual insights, guiding your understanding and driving analytical decisions.*

[^1]: The iris dataset is a classic example for demonstrations, offering numeric and categorical variables that lend themselves well to ggplot2's grammar of graphics approach.  

### Chapter 6: Data Visualisation with ggplot2

#### 6.3 Scales, Coordinate Systems, and Facets for Complex Displays

*Building on the grammar of graphics, once you understand geoms and aesthetics, you can do much more to tailor your visualisation. Scales allow you to control how data values map onto aesthetic attributes—colour gradients, size ranges, or axis transformations. Coordinate systems determine how your data is projected onto the plane, affecting how shapes and relationships appear. Faceting lets you create grids of plots, each displaying a subset of the data, enabling easy comparisons across categories or conditions.*

*Imagine you’re organising a gallery exhibition. The data are your artworks, geoms and aesthetics are how you paint them, but scales determine the lighting and spacing, the coordinate systems choose how you hang them (maybe in a line or a circle), and facets are like separate rooms, each showcasing a different theme. Together, these elements shape the environment in which your data story is told, making it easier and more intuitive for the viewer to grasp insights.*

---

#### Understanding Scales

- **Concept**: Scales connect data values to aesthetic properties. For example, when you map a variable to colour, a scale translates numeric or categorical values into colours. Similarly, mapping a variable to size uses a scale to define how numeric values map onto point sizes.

- **Common Adjustments**:  
  - Change the colour scale to a different palette for better contrast.  
  - Apply a log scale to the x-axis if data span several orders of magnitude.  
  - Adjust transparency or size to handle overplotting and highlight patterns.

*Think of scales as the translator between the data space and the visual space. By default, ggplot2 chooses sensible defaults, but you can customise them to sharpen the message.*[^1]

For example, consider we have a scatterplot of `Sepal.Length` vs `Petal.Length` from the `iris` dataset:

\\`\\`\\`r
iris_data <- data.table::as.data.table(datasets::iris)

ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point() +
  ggplot2::labs(
    title = "Default Scale for Colour",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

*The default colour scale might be fine, but what if we want a different palette or to emphasise a different variable’s range by adjusting the x or y scale?*

#### Modifying Scales

- **Changing Colour Scales**:

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point() +
  ggplot2::scale_colour_brewer(palette = "Set1") +
  ggplot2::labs(
    title = "Custom Colour Palette",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

Now, colours come from the “Set1” Brewer palette, providing a different aesthetic feel.

- **Transforming Axes**: If `Sepal.Length` varies widely and we want to see patterns on a smaller scale, consider a log scale:

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length)) +
  ggplot2::geom_point() +
  ggplot2::scale_x_log10() +
  ggplot2::labs(
    title = "Log-Transformed X-axis",
    x = "Log of Sepal Length",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

*This transforms the x-axis so that equal distances represent equal multiplicative changes, revealing patterns hidden by a linear scale.*

---

#### Coordinate Systems

- **Concept**: The default coordinate system is Cartesian (x-y plane). Changing coordinates can produce dramatic effects:
  - Polar coordinates (`coord_polar()`) turn bar charts into pie charts.
  - Flipping coordinates (`coord_flip()`) makes horizontal boxplots or bar charts easy.
  - Maps or other specialized plots might use specific coordinate systems.

*By adjusting coordinates, you’re changing how data is mapped onto the canvas. It’s like rotating your painting or viewing the scene from a different angle, offering fresh perspectives.*

For instance, to flip axes (often useful for long category labels on x-axis):

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Species, y = Petal.Length)) +
  ggplot2::geom_boxplot(fill = "lightgreen") +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "Flipped Coordinates for Boxplot",
    x = "Petal Length (cm)",
    y = "Species"
  )
\\`\\`\\`

*Now species names run vertically, making them easier to read if they were long strings.*

---

#### Facets: Splitting Data into Multiple Panels

- **Concept**: Faceting creates subplots (small multiples) each showing a subset of data. For instance, facet by `Species` in the `iris` dataset to get one scatterplot per species. Facets make it easy to compare patterns across categories without cluttering a single plot.

- **Mechanics**: `facet_wrap()` and `facet_grid()` are the main tools:
  - `facet_wrap(~ variable)` splits the data by one variable, arranging plots in a wrapping grid.
  - `facet_grid(rows ~ cols)` creates a matrix of panels defined by two variables.

*Facets are like dividing a gallery into rooms, each room featuring data from one category. Observers can move from room to room to see differences in a structured way.*

For example, facet by species:

\\`\\`\\`r
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length)) +
  ggplot2::geom_point(colour = "blue") +
  ggplot2::facet_wrap(~ Species) +
  ggplot2::labs(
    title = "Facetted Scatterplots by Species",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )
\\`\\`\\`

*Each facet shows one species, making it clear how patterns differ. Maybe Setosa forms a distinct cluster at smaller sepal lengths, while Virginica occupies a range of longer petals.*

---

#### Combining These Components

*Scales, coordinate systems, and facets are not mutually exclusive. You can:
- Use a log scale on one axis,
- Employ a polar coordinate system,
- Facet by a categorical variable,
- And apply a custom colour scale.

All at once. This flexibility transforms ggplot2 into a versatile tool for advanced data storytelling.*

For example, consider a dataset of car characteristics (if we had one loaded), we could:  
- Map `horsepower` to x, `mpg` to y, `cyl` to colour.  
- Use `scale_colour_viridis()` for a sophisticated colour map.  
- `facet_wrap(~ gear)` to split by the number of gears.  
- `coord_flip()` if vertical better suits the context.

*With each element layered thoughtfully, you produce a multifaceted visualization that clarifies complex relations.*

---

#### Mathematical Underpinnings

- **Scales as Mappings**: A scale defines a function \( f: \text{Data Space} \to \text{Aesthetic Space} \). For example, a linear scale on x: \( x_{plot} = a + b \cdot x_{data} \). Log scales: \( x_{plot} = a + b \log(x_{data}) \). Colour scales: map numeric ranges to a colour spectrum or categories to discrete colour sets.

- **Coordinates as Transformations**: Changing coordinates applies a mathematical transformation to (x,y). For polar coordinates:  
  $$
  x_{plot} = r \cos(\theta), \quad y_{plot} = r \sin(\theta)
  $$
  
  where \( r \) and \( \theta \) come from original data mappings.

- **Facets as Data Partitioning**: Facets create subsets of data defined by categorical variables. Each facet panel represents a sub-dataset. This involves no direct mathematical transformation of the coordinates, but conceptually it’s like partitioning the domain into disjoint subsets.

---

#### Practical Guidance

- **Use Scales to Improve Clarity**: If data points bunch up in a corner, a log scale might separate them. If categorical colours clash, choose a different colour palette.
- **Select Coordinates Wisely**: Polar coordinates can turn a bar chart into a pie chart. Flipped coordinates can make labels more readable.  
- **Facet for Comparisons**: When you have categories and want to compare distributions, patterns, or relationships side by side, facets are your friend.

*Strive to highlight the story behind the data. Scales clarify patterns, coordinates introduce alternative perspectives, and facets ensure each category’s narrative stands out.*

---

#### Real-World Example

*Imagine a dataset of world development indicators: GDP per capita, life expectancy, population, continent. You could:
- Map GDP per capita to x-axis, life expectancy to y-axis.
- Apply a log scale to GDP since it spans several orders of magnitude.
- Colour points by continent, adjusting the colour scale to a readable palette.
- Facet by year, so each year is a separate panel, showing how relationships evolve over time.

In one plot, you reveal temporal trends, continental differences, and the nonlinear relationship between wealth and health.*

---

#### Next Steps

*Having learned about scales, coordinate systems, and facets, you can create more complex and meaningful plots. The next chapters explore theming, labelling, and formatting to polish your visuals to publication quality, as well as integrating ggplot2 with data.table for efficient workflows. Remember, data visualisation is a craft: each decision about scale, coordinate, and facet refines your art, making the patterns clearer and insights stronger.*

[^1]: Colour schemes from packages like RColorBrewer or viridis provide carefully designed palettes for colourblind safety and aesthetic appeal, ensuring your scales communicate effectively to all viewers.

### Chapter 6: Data Visualisation with ggplot2

#### 6.4 Themes, Labels, and Custom Formatting for Publication-Quality Graphics

*Up to this point, we have learned how to build informative plots using geoms, aesthetics, scales, coordinate systems, and facets. These tools are essential for revealing patterns in data. However, if you aim to present your findings to others—colleagues, clients, or a broader audience—you must consider the overall look and feel of your graphs. Publication-quality graphics require careful attention to details: choosing the right themes, adjusting labels and annotations, and applying custom formatting to ensure clarity, elegance, and professionalism.*

*Think of a graph as not just a functional blueprint, but as a painting intended for an exhibition. While your underlying data and patterns form the “subject” of the painting, a well-chosen frame (theme), clear titles and captions (labels), and subtle finishing touches (custom formatting) transform a functional draft into a polished masterpiece.*

---

#### Themes: Setting the Visual Tone

- **Concept**: A theme in ggplot2 adjusts non-data elements like background colour, grid lines, and font sizes. By switching themes, you instantly change the mood and clarity of your plot. You can choose a minimalistic theme to reduce distractions or a classic theme for a more traditional look.

- **Common Themes**:  
  - `theme_gray()`: The default, a balanced background with grey panel.  
  - `theme_bw()`: A cleaner look with a white background and black grid lines.  
  - `theme_minimal()`: A sparse grid, lots of white space—great for presentations.  
  - `theme_classic()`: Reminiscent of traditional statistical graphics with few grid lines.

*Themes are like interior design for your data. The same furniture (data and geoms) arranged in a minimalist loft vs. a warmly lit study creates different impressions.*[^1]

#### Demonstration with Themes

*Let’s take the `iris` dataset again and create a scatterplot, then apply different themes:*

\\`\\`\\`r
iris_data <- data.table::as.data.table(datasets::iris)

base_plot <- ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point() +
  ggplot2::labs(
    title = "Iris Sepal vs Petal Length",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  )

# Default theme
base_plot

# Minimal theme
base_plot + ggplot2::theme_minimal()

# Black and white theme
base_plot + ggplot2::theme_bw()
\\`\\`\\`

*Compare the outputs and decide which suits your audience. For a scientific paper, `theme_bw()` might feel professional. For a presentation, `theme_minimal()` looks modern and uncluttered.*

---

#### Labels, Titles, and Annotations

- **Meaningful Titles and Axis Labels**:  
  Titles give context, axis labels clarify units and meanings. Without them, viewers guess what the data represent. Include units in axis labels whenever possible to prevent confusion.

- **Subtitles and Captions**:  
  Add a subtitle for extra context or a caption for data source attribution. This is particularly helpful when communicating complex data to a non-technical audience.

- **Annotations and Text**:  
  Sometimes you must highlight a specific point or region in your plot. You can add text or arrows (using `geom_text()`, `geom_label()`) to direct attention. These annotations guide viewers through the narrative you’re telling.

For example, if one point is an outlier, you can annotate it:

\\`\\`\\`r
# Let's identify an outlier-like point: the flower with max Petal.Length
max_petal <- iris_data[which.max(Petal.Length)]
base_plot +
  ggplot2::geom_text(
    data = max_petal,
    ggplot2::aes(label = "Max Petal Length"),
    vjust = -1,
    size = 3,
    colour = "red"
  )
\\`\\`\\`

*This adds a text label above the point with the largest Petal.Length, drawing immediate attention.*

---

#### Customising Axes and Legends

- **Axis Customisation**:  
  You can rotate x-axis labels if they’re long, or use `scale_x_continuous()` and `scale_y_continuous()` to set breaks and labels manually. For instance, if you only want axis ticks at certain values:

\\`\\`\\`r
base_plot +
  ggplot2::scale_x_continuous(breaks = seq(4,8,by=1), labels = paste0(seq(4,8,by=1), " cm"))
\\`\\`\\`

*Now the x-axis has ticks at 4, 5, 6, 7, 8 cm, each labelled with “cm” to remind viewers of the unit.*

- **Legend Control**:  
  If you’ve coloured points by species, a legend appears by default. You can move it, change its title, or remove it if it’s redundant. For example:

\\`\\`\\`r
base_plot +
  ggplot2::theme(legend.position = "bottom") +
  ggplot2::labs(colour = "Iris Species")
\\`\\`\\`

*This moves the legend below the plot and changes the legend title.*

---

#### Putting It All Together for Publication

*When preparing a plot for publication (in a report, a journal article, or a presentation), consider the following:*

- **Consistency**: Use a consistent theme across all plots in the publication, ensuring a cohesive look.
- **Simplicity**: Avoid unnecessary grid lines or distracting elements. Minimalist themes help focus on data.
- **Readability**: Ensure labels are large enough, contrasts are sufficient, and colour schemes are friendly to those with colour vision deficiencies.  
- **Contextual Information**: Add a subtitle describing the dataset or analysis. Add footnotes if needed to attribute data sources or clarify assumptions.

*The goal is to produce a plot that stands alone as a self-contained piece of communication, understandable even if someone just sees that figure without reading the entire text.*

---

#### Example: Final Polished Plot

*Suppose we aim for a publication-quality plot highlighting species differences in the iris dataset. Let’s choose `theme_classic()`, add a meaningful title and subtitle, label axes clearly, use a colour scheme that’s colourblind-friendly, and place the legend at the bottom.*

\\`\\`\\`r
final_plot <- ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point(alpha = 0.8) +
  ggplot2::labs(
    title = "Comparing Iris Species: Sepal vs. Petal Length",
    subtitle = "Iris flower measurements from Fisher's dataset",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)",
    colour = "Species"  
  ) +
  ggplot2::scale_colour_brewer(palette = "Set2") +
  ggplot2::theme_classic() +
  ggplot2::theme(
    legend.position = "bottom",
    plot.title = ggplot2::element_text(face = "bold", size = 14),
    plot.subtitle = ggplot2::element_text(size = 12),
    axis.title = ggplot2::element_text(size = 12),
    axis.text = ggplot2::element_text(size = 10),
    legend.text = ggplot2::element_text(size = 10)
  )

final_plot
\\`\\`\\`

*This plot has a clean white background, a bold title, a subtitle for extra context, carefully chosen axis labels, and a legend placed below the plot. Colours are chosen from a Set2 palette, which is designed to be pleasing and somewhat colourblind-friendly. The alpha channel reduces overplotting by making points slightly transparent.*

---

#### Mathematical Connections

*While aesthetics and themes are not directly mathematical, consider:
- Axis transformations (e.g., log scales) are mathematical transforms of coordinates.
- Choosing tick breaks and labels can reflect knowledge of appropriate rounding or numeric formatting.
- Careful theming might not be mathematical, but it respects cognitive principles: simplicity, grouping, and good figure-ground contrast are backed by research in visual perception.*

---

#### Real-World Impact

*In practice, a well-formatted plot can mean the difference between your message being understood at a glance or being missed entirely. In scientific papers, a crisp, annotated figure can save paragraphs of text. In business presentations, a polished plot can convince stakeholders more swiftly than raw tables.*

*As you refine your EDA into final outputs, think like a graphic designer as well as a data analyst. The data provides the story, but your theme, labels, and formatting set the stage and direct the audience’s attention where it matters most.*

---

#### Next Steps

*Having mastered themes, labels, and formatting, you are ready to create truly professional graphs. Upcoming sections will explore integrating ggplot2 with data.table for efficiency, extending ggplot2 with additional layers and stats, and even producing interactive or animated graphics. With your foundation in aesthetics and styling, these advanced techniques become even more powerful.*

[^1]: Additional theme packages exist, like `ggthemes`, offering ready-made professional and journal-styled themes for various publications or aesthetics.  

### Chapter 6: Data Visualisation with ggplot2

#### 6.5 Integrating ggplot2 with data.table for Efficient Data Pipelines

*As you progress in data analysis, you will often handle increasingly large and complex datasets. The efficiency and elegance of your workflow matter, especially when you find yourself performing numerous data manipulations before creating your visualisations. One powerful advantage of using `data.table::` in combination with `ggplot2::` is the seamless integration between fast data wrangling and flexible plotting, all without switching between radically different paradigms or adding unnecessary complexity.*

*Think of `data.table::` as a high-performance kitchen: you chop, slice, and prepare your data ingredients at lightning speed. Then, `ggplot2::` is the fine plating technique, arranging those carefully prepped ingredients into a visually stunning dish. By mastering both tools together, you create a workflow where data transformations and visualisations flow naturally, resulting in a more efficient pipeline that saves time and reduces errors.*[^1]

---

#### Why Integrate data.table with ggplot2?

- **Performance and Memory Efficiency**:  
  `data.table::` is built for speed, handling large datasets gracefully. You can preprocess and summarise data quickly before plotting. This is crucial when working with millions of rows—performing heavy lifting in `data.table::` ensures you only pass the essential, aggregated, or filtered data to `ggplot2::`.

- **Consistent Syntax and Workflow**:  
  Sticking to base R plus `data.table::` for manipulation and `ggplot2::` for plotting avoids mixing paradigms. This consistency reduces cognitive overhead: you think in terms of data operations and layering of aesthetics rather than switching to another ecosystem.

- **Direct Plotting from Preprocessed Results**:  
  After creating summary tables, grouping data, or computing statistics with `data.table::`, you can feed the resulting `data.table::` directly into `ggplot2::`. This minimises intermediate steps, making your code cleaner and more transparent.

*Imagine a pipeline: raw data enters on one side, you perform grouping, filtering, and summarising with `data.table::`, and out comes a neatly structured result table. This final table becomes the input to `ggplot2::`, where you quickly create the final chart. The synergy between these tools streamlines the entire process.*


---

#### Demonstration with the iris Dataset

*We’ll use the `iris` dataset once again for demonstration. Suppose we want to compare the average petal length for each species and create a bar chart showing these averages with error bars representing the standard deviation. We can do all the summarisation in `data.table::` first, then plot directly with `ggplot2::`.*

*Steps:*
1. **Load and inspect data**: Import iris into a `data.table::` and look at the first few rows.
2. **Summarise by Species**: Compute mean and standard deviation of `Petal.Length` grouped by `Species`.
3. **Plot the summary**: Use `geom_col()` for bars and `geom_errorbar()` for error bars.

\\`\\`\\`r
# Convert iris to data.table
iris_data <- data.table::as.data.table(datasets::iris)
print(head(iris_data))
\\`\\`\\`

*Now, summarise `Petal.Length` by `Species`:*

\\`\\`\\`r
summary_data <- iris_data[ , .(
  mean_petal_length = mean(Petal.Length),
  sd_petal_length = sd(Petal.Length)
), by = Species]
print(summary_data)
\\`\\`\\`

*We have a neat summary: for each species, we know the average and standard deviation of the petal length. Next, we create a bar chart with error bars.*

\\`\\`\\`r
ggplot2::ggplot(data = summary_data, ggplot2::aes(x = Species, y = mean_petal_length)) +
  ggplot2::geom_col(fill = "lightblue", colour = "black") +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = mean_petal_length - sd_petal_length,
                                      ymax = mean_petal_length + sd_petal_length),
                         width = 0.2) +
  ggplot2::labs(
    title = "Average Petal Length by Iris Species",
    subtitle = "Including standard deviation as error bars",
    x = "Species",
    y = "Mean Petal Length (cm)"
  ) +
  ggplot2::theme_minimal()
\\`\\`\\`

*In just a few lines, we efficiently computed statistics with `data.table::` and then directly plotted them using `ggplot2::`. This integrated approach minimises overhead—no need for complex intermediate steps or separate data structures.*

---

#### Advanced Example: Filtering and Transformation Before Plotting

*Consider a scenario where you have a large dataset of daily temperatures from multiple weather stations. Before plotting, you might want to:*

- Filter data to a specific region or time period.
- Group by station and month, computing average temperatures.
- Subset only the top 5 stations with the highest variability for clarity.

*All these transformations happen in `data.table::`, and once done, you pass the resulting summary to `ggplot2::` for quick visualisation.*

*Assume we have a large CSV file of daily temperatures with columns: `station_id`, `date`, and `temp`. For demonstration, let’s simulate some data.*[^2]

\\`\\`\\`r
# Simulate data (for demonstration)
set.seed(123)
stations <- paste0("STN", 1:10)
dates <- seq(as.Date("2020-01-01"), as.Date("2020-12-31"), by="day")
some_data <- data.table::data.table(
  station_id = sample(stations, length(dates)*10, replace = TRUE),
  date = rep(dates, each = 10),
  temp = rnorm(length(dates)*10, mean = 15, sd = 5)
)

# Compute monthly averages per station
some_data[ , month := format(date, "%Y-%m")]

monthly_stats <- some_data[ , .(
  mean_temp = mean(temp),
  sd_temp = sd(temp)
), by = .(station_id, month)]

# Choose top 5 stations by highest overall sd_temp
station_sd <- monthly_stats[ , .(overall_sd = sd(mean_temp)), by = station_id]
top_stations <- station_sd[order(-overall_sd)][1:5, station_id]

# Filter monthly_stats to these top stations
plot_data <- monthly_stats[station_id %in% top_stations]

# Plot monthly mean temperatures for top stations
ggplot2::ggplot(data = plot_data, ggplot2::aes(x = month, y = mean_temp, group = station_id, colour = station_id)) +
  ggplot2::geom_line() +
  ggplot2::labs(
    title = "Monthly Mean Temperatures for Top 5 Variable Stations",
    subtitle = "Data simulated for demonstration",
    x = "Month",
    y = "Mean Temperature (°C)",
    colour = "Station ID"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
\\`\\`\\`

*Here we used `data.table::` extensively to filter, summarise, and subset data, then passed the final table to `ggplot2::`. The result is a clean workflow, from raw data to a final plot, all within a few straightforward steps.*

---

#### Mathematical Insight

*From a mathematical standpoint, `data.table::` operations let you perform transformations like:  
$$X_{\text{filtered}} = \{x \in X: \text{condition}(x)\},$$  
where you subset your data to elements meeting certain criteria. Grouping and summarising corresponds to mapping sets of observations to aggregated values (e.g., $$\bar{x} = \frac{1}{n}\sum x_i$$).

Once summarised, the final numeric results serve as input to `ggplot2::`. There, no heavy computations occur—just mapping values onto aesthetics. The pipeline ensures that expensive computations happen once (in data.table), and plotting is lightweight and direct.*

---

#### Practical Advice

- **Preprocessing in data.table::**: Do all your filtering, grouping, and summary statistics before plotting. This approach reduces complexity and ensures `ggplot2::` only deals with tidy, ready-to-visualise datasets.
- **Keep the Final Table Small**: Summaries often drastically reduce dataset size. This not only makes plotting faster but also clarifies the message by focusing on key statistics rather than raw data overload.
- **Reproducible Pipelines**: By writing functions that first manipulate data using data.table, then pass the result to ggplot2, you create reusable scripts. Adjusting a filter or an aggregation step becomes easy, and the final plot updates accordingly.

---

#### Real-World Outcomes

*In a real analytical environment—be it scientific research, business intelligence, or data journalism—you’ll often perform dozens of transformations. By the time you visualise the data, you want a concise, meaningful subset or summary. The data.table + ggplot2 combo is a potent duo: fast data manipulation and flexible plotting, all within a consistent R workflow.*

*This synergy leads to faster experimentation: you can try different aggregations, run the code again, and see how the plot changes. This feedback loop encourages deeper exploration, more refined analysis, and ultimately, better insights.*

---

#### Next Steps

*Having learned how to integrate data.table and ggplot2, you can now build efficient data pipelines that transform your data and produce high-quality visuals. In upcoming sections, we’ll explore extending ggplot2 with additional layers and stats, and even creating interactive or animated graphics, building upon the foundation of efficient data preparation and flexible visualisation.*

[^1]: Integrating data.table and ggplot2 is a common best practice in data science workflows using R, as it leverages the strengths of both tools.  
[^2]: Synthetic data generated here is purely for demonstration and does not represent any real source. In practice, you would start by reading a large CSV with `data.table::fread()` and applying real filters and summaries.  

### Chapter 6: Data Visualisation with ggplot2

#### 6.6 Extending ggplot2 with Additional Layers, Stats, and Packages

*So far, we have explored the core capabilities of ggplot2: geometric objects, aesthetics, scales, themes, and facets. These are the building blocks that let you craft a wide range of visualisations. However, one of ggplot2’s greatest strengths is its extensibility. As your analytical needs grow more sophisticated, you can leverage additional layers, statistical transformations, and even external packages that build on top of ggplot2 to create advanced, customised, and more insightful graphics.*

*Think of ggplot2 as a living ecosystem. At its heart, you have the grammar of graphics, but many contributors have developed specialised geoms, stats, and add-on packages. These extensions let you create complex maps, interactive visuals, network graphs, and more. It’s like starting with a basic toolbox and then discovering an entire workshop of precision instruments that help you perfect your craft.*

---

#### Beyond the Basics: Additional Geoms and Stats

- **More Than Points and Bars**:  
  ggplot2 includes a variety of geometric objects—`geom_area()`, `geom_density()`, `geom_ribbon()`, `geom_errorbar()`, and more—that address specific needs. For example, `geom_violin()` provides a rich view of a distribution’s shape, combining elements of a boxplot and a kernel density plot.

- **Custom Statistics (stats)**:  
  While geoms handle visual marks, stats perform calculations on data. For instance, `geom_smooth()` uses a smoothing statistic to fit a trend line. If you want to apply a custom statistical transformation, you might write your own `stat_` function. This is more advanced but allows for nearly unlimited flexibility.

*As your questions become more specialised, these additional geoms and stats let you tailor the plot to exactly the kind of story you’re telling. For example, a violin plot might reveal subtle distribution differences that a boxplot hides. A density ridge plot from an extension package can show overlapping distributions elegantly.*

---

#### Using Extension Packages

- **The Ecosystem of Extensions**:  
  Many packages extend ggplot2, creating new geoms or scales. Some popular ones include:
  - **ggridges**: For “ridgeline” plots that stack multiple densities elegantly.
  - **ggforce**: Adds tools for complex layouts, zooming, and constrained scales.
  - **ggrepel**: Improves text label placement to reduce overlap and clutter.
  - **ggmap**: Integrates with spatial data for mapping backgrounds using services like Google Maps.
  - **patchwork**: Easily combine multiple ggplots into a single layout without complex faceting.
  
*Each of these packages is like adding new brush techniques to your painting skillset, allowing you to portray data in more nuanced ways.*[^1]

---

#### Demonstration: Using ggrepel for Better Labels

*When you try to label points in a scatterplot with `geom_text()`, labels can overlap, making the plot messy. `ggrepel` adds `geom_text_repel()` and `geom_label_repel()` to automatically adjust label positions, reducing clutter.*

*Install if needed and then demonstrate: For the iris dataset, imagine labelling the species with text repelling each other.*  
**Note**: If real-world usage requires installation, you would run `install.packages("ggrepel")` first, but here we assume it’s allowed for demonstration.

\\`\\`\\`r
# We'll just highlight a few points from the iris dataset
iris_data <- data.table::as.data.table(datasets::iris)

# Let's pick a few rows to label, for demonstration
subset_data <- iris_data[Species == "setosa"][1:5]

# Plot points, then add text labels with ggrepel
ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length)) +
  ggplot2::geom_point(colour = "blue") +
  ggrepel::geom_text_repel(data = subset_data,
                           ggplot2::aes(label = paste("Row", .I)),
                           colour = "red") +
  ggplot2::labs(
    title = "Using ggrepel for Non-Overlapping Labels",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  ) +
  ggplot2::theme_minimal()
\\`\\`\\`

*Without `ggrepel`, labels might overlap. With it, text labels “repel” each other, improving readability.*

---

#### Creating Maps with ggplot2 and Extensions

*Visualising spatial data often requires more than just scatterplots. The `ggplot2` ecosystem includes packages like `ggmap` or `sf` integration for plotting maps. You can overlay data points on geospatial backgrounds, display polygons for regions, or show density contours over actual geographic maps.*

*For example, if we had a dataset of latitude, longitude, and some measurement, we could:*

1. Preprocess data with `data.table::` to select a region.
2. Use `ggmap` or `sf` to load a background map or shapefile.
3. `geom_point()` or `geom_polygon()` to place data on top of the map.

*This transforms complex spatial analysis into clear geographic contexts, answering questions like “Where are events concentrated?” or “How do values vary across regions?”*

---

#### Complex Layouts with patchwork

*Sometimes a single plot is not enough. You want to combine multiple ggplot2 visuals into one figure. The `patchwork` package allows you to use the `+` operator to arrange multiple plots side by side or on top of each other without manual grob manipulation.*

*For instance, if you have two plots created as variables `p1` and `p2`, you can do:*

\\`\\`\\`r
# Suppose p1 and p2 are ggplot objects from previous code
# p_final <- p1 + p2
# p_final
\\`\\`\\`

*`patchwork` can even define layouts (like `p1 + p2 + plot_layout(ncol = 1)`) or arrange multiple plots in a grid. This is invaluable for reports or dashboards where multiple related graphs must be viewed together.*

---

#### Writing Custom Functions and Stats

*If you have unique statistical needs, you can write custom functions that summarise data in `data.table::`, then pass these summaries as data frames to `ggplot2::`. If you’re more advanced, you can define your own `stat_` layers that transform data on-the-fly within the plotting pipeline. This lets you integrate custom statistical logic seamlessly into your ggplot2 visuals.*

*For example, if you want a custom smoothing method or a novel way to bin data, you can implement a new `Stat*` object. This is a more advanced topic, but it shows ggplot2’s architecture is flexible enough to incorporate your domain-specific methods.*

---

#### Mathematical Considerations

*Extension layers and packages often encapsulate advanced mathematical operations:

- **Density Estimations**: Additional geoms or stats may implement different kernel density estimators or smoothing algorithms.
- **Map Projections**: Spatial packages deal with mathematical transformations from spherical coordinates (lat/long) to planar maps.
- **Custom Stats**: Could involve fitting models, computing residuals, or performing complex calculations $$f(x) = \sum_{i}g(x_i)$$ on subsets of data.

This mathematical sophistication remains behind the scenes, while you focus on the conceptual and interpretive aspects of your visualisation.*

---

#### Workflow and Efficiency

*Integrating these extensions into your workflow is straightforward:

1. Use `data.table::` to load and preprocess large datasets efficiently.
2. Summarise and transform data to the desired form.
3. Use ggplot2 geoms and aesthetics to create the main plot.
4. Add extension layers or packages if needed—be it `ggrepel` for labels, `ggforce` for geometric manipulations, or a custom stat function for special transforms.

This pipeline ensures you can tackle complex visualisation challenges without leaving the ggplot2 universe or resorting to manual, time-consuming workarounds.*

---

#### Real-World Example

*Imagine you’re analysing customer data for a retail chain. After cleaning and summarising transactional data with `data.table::`, you want to display monthly sales trends, annotate key product launch dates without text overlap, and highlight top 3 stores separately. You could:
- Use `geom_line()` for sales trends over time.
- Add `geom_vline()` for product launch dates and `ggrepel::geom_text_repel()` to label these lines unobtrusively.
- Use `facet_wrap()` or `patchwork` to show separate panels for top stores.
- If necessary, apply a custom stat to aggregate and display moving averages.

All achieved within the flexible `ggplot2::` ecosystem extended by a few carefully chosen packages.*

---

#### Next Steps

*Now that you see how easily ggplot2 can be extended and customised, you’re prepared to push your visualisation skills even further. The next sections will explore even more advanced capabilities, including interactive and animated graphics. By mastering these extensions, you ensure that no visualisation challenge is too large or too unusual for you to handle.*

[^1]: The ggplot2 extension gallery (https://exts.ggplot2.tidyverse.org/) provides an overview of many add-on packages, offering inspiration and solutions for specialised plotting needs.  

### Chapter 6: Data Visualisation with ggplot2

#### 6.7 Interactive and Animated Visualisations for Enhanced Communication

*Up to now, we have focused on static visualisations—plots that exist as still images on the screen or page. While these are powerful, there are times when a more dynamic approach can enhance understanding and engagement. Interactive plots let viewers hover over points for more details, zoom into regions of interest, or filter categories on the fly. Animated plots can reveal how data evolves over time or how distributions morph as parameters change.*

*Imagine presenting your analysis to a non-technical audience: a static scatterplot might be comprehensible, but an interactive one that shows data labels on hover can be more intuitive and engaging. If your data has a temporal component, an animated line chart smoothly showing monthly changes will be more compelling than a static snapshot. These techniques elevate your communication, turning data into an experience.*

---

#### Interactivity: Using plotly with ggplot2

- **Concept**: `plotly::` allows you to convert static ggplot2 plots into interactive web-based graphics. The `plotly::ggplotly()` function takes your existing ggplot2 object and makes it interactive. Hover tooltips, pan, zoom, and legend toggling become available with no extra data manipulation.

- **Why Interactive?**: Interactivity fosters exploration. Stakeholders can focus on details that matter to them, discover outliers by hovering, or compare subsets without asking the analyst for a new static plot.

*Think of static plots as printed photographs and interactive plots as digital images you can zoom, annotate, and explore. Interactivity transforms a one-way communication into a dialogue between the viewer and the data.*[^1]

#### Demonstration: Converting a ggplot to Interactive

*We will use the `iris` dataset again. Suppose we have a scatterplot of Sepal.Length vs Petal.Length coloured by Species.*

\\`\\`\\`r
iris_data <- data.table::as.data.table(datasets::iris)

# Basic ggplot
p <- ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point() +
  ggplot2::labs(
    title = "Iris Sepal vs Petal Length (Static)",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)"
  ) +
  ggplot2::theme_minimal()

# Convert to interactive with plotly
interactive_p <- plotly::ggplotly(p)
interactive_p
\\`\\`\\`

*Now hovering your mouse over points in the rendered version (when viewed in a browser or RStudio’s Viewer) shows details, and you can zoom in and out. Without rewriting the plot logic, `plotly::` just added a layer of interactivity.*

---

#### Animation: Using gganimate for Temporal or Parametric Changes

- **Concept**: `gganimate::` extends ggplot2 to produce animated GIFs or videos from your plot by adding a “time” dimension (or any variable sequence). For datasets with temporal components, you might show monthly changes in sales, daily temperature variations across seasons, or progressive fitting of a model as a parameter changes.

- **Why Animate?**: Animation can reveal dynamics that are hard to see in static plots. For example, a line chart changing over time clarifies trends, cycles, and anomalies more vividly than multiple static snapshots.

*Visualising data as a movie is like flipping through the pages of a flipbook. Instead of guessing how things evolve, you watch them evolve in real-time, making patterns jump out and improving comprehension.*

#### Demonstration: Creating an Animated Plot

*Let’s simulate some time series data: monthly sales for a few products. After summarising with `data.table::`, we’ll create a plot that transitions through months, showing how sales evolve.*

\\`\\`\\`r
# Simulate monthly sales data
set.seed(123)
dates <- seq(as.Date("2021-01-01"), as.Date("2021-12-31"), by="month")
products <- c("A", "B", "C")

sales_data <- data.table::data.table(
  product = rep(products, each = length(dates)),
  month = rep(dates, times = length(products)),
  sales = round(rnorm(length(products)*length(dates), mean = 100, sd = 20))
)

print(sales_data)

# We want a line plot that shows how each product's sales change over months, animated by month.
base_anim_plot <- ggplot2::ggplot(data = sales_data, ggplot2::aes(x = product, y = sales, group = product, colour = product)) +
  ggplot2::geom_line(stat = "summary", fun = "mean", size = 1) + 
  ggplot2::labs(
    title = "Monthly Sales by Product",
    subtitle = "Month: {frame_time}",
    x = "Product",
    y = "Sales (Units)"
  ) +
  ggplot2::theme_minimal()

# Add gganimate transition
anim_plot <- base_anim_plot +
  gganimate::transition_time(as.numeric(sales_data$month)) +
  gganimate::ease_aes('linear')

# To view this animation, you would use gganimate::animate(anim_plot) in an interactive session
# or gganimate::anim_save("sales_animation.gif", anim_plot)
\\`\\`\\`

*In this code, `transition_time()` creates frames for each month. The `{frame_time}` in the subtitle updates dynamically. Rendering this animation (in an environment that supports it) produces a moving line chart showing each product’s monthly sales changing as time passes.*

---

#### Combining Interactivity and Animation

*You can first produce a gganimate animation and then convert frames into an interactive HTML widget, or produce interactive visuals that evolve through user input. While combining both simultaneously can be complex, the principle is the same: data.table for preprocessing, ggplot2 for base visuals, `gganimate::` for animation, and `plotly::` for interactivity, depending on the final medium and audience.*

---

#### Mathematical Considerations

*Animation often involves parameterising time or another variable. If month is denoted as \( t \), your plot frames might represent a function \( f(x; t) \) evolving over \( t \). Interactivity and animation do not change the underlying mathematical relationships but improve how these relationships are conveyed. You might, for example, animate a line plot of $$y = \sin(t \cdot x)$$ as \( t \) varies to illustrate periodic functions more intuitively.*

---

#### Real-World Use Cases

- **Interactive Explorations**: Internal dashboards where analysts can hover over data points, identify outliers, or filter categories on demand.
- **Public-Facing Visualisations**: News articles that let readers explore data interactively, thereby increasing engagement and understanding.
- **Teaching and Presentations**: Animations that show step-by-step model fitting or the evolution of a pandemic’s spread over time add narrative and clarity.

*At conferences, presenting a static slide of yearly temperature changes is informative, but animating that change over decades can evoke a more visceral understanding of trends and anomalies.*

---

#### Practical Tips

- **Keep It Simple**: Interactivity and animation are powerful, but too much complexity can overwhelm. Choose the simplest approach that conveys your point.
- **Consider the Medium**: If you’re sharing results in a static PDF, animations won't animate. Instead, provide a link to an HTML version or a GIF. Interactivity requires HTML or Shiny dashboards.
- **Preprocessing Counts**: As always, use `data.table::` to filter and summarise your data beforehand. With animations and interactivity, performance matters more because the viewer might interact in real-time.

---

#### Next Steps

*Having learned how to add interactivity and animation, you can now communicate dynamic processes and complex datasets with greater impact. In the next sections, we’ll refine our approach to communicating results effectively and integrating all these techniques into a cohesive workflow, ensuring your visualisations are not only correct and insightful but also compelling and memorable.*

[^1]: The `plotly::` package is one popular tool for interactive visuals. Others exist (like `leaflet::` for maps), each providing unique features. For animations, `gganimate::` is widely used due to its close integration with ggplot2.  

### Chapter 6: Data Visualisation with ggplot2

#### 6.8 Communicating Results Effectively: Visual Best Practices

*Crafting a beautiful and insightful plot is not just about clever code or powerful tools. It is also about **communication**. You want your visuals to tell a story, to guide viewers through complex data, and to let them discover insights without confusion. Achieving this requires applying visual best practices—ideas drawn from design, cognitive psychology, and storytelling.*

*Think of your plot as a language. Just as good writing uses clear sentences and avoids jargon, good visualisation uses well-chosen colours, clear labels, and sensible layouts. Your goal is to ensure that anyone, from a fellow data scientist to a curious layperson, can look at your graph and understand its meaning without struggling. This approach ensures your hard work in data analysis pays off in real understanding.*

---

#### Principles of Good Visual Communication

- **Simplicity**:  
  Strip away unnecessary elements: extra grid lines, distracting backgrounds, overly complex legends. If it does not add information, consider removing it. Simplicity ensures viewers focus on data patterns rather than chart decorations.

- **Clarity**:  
  Use meaningful axis labels, units, and titles. Help viewers see what each variable represents. If you have a legend, ensure it’s clearly labelled. Make sure fonts are large enough and contrasts are high enough for readability.

- **Consistency**:  
  If you produce multiple plots for the same report, use consistent themes, colour palettes, and labeling conventions. Consistency reduces cognitive load; your audience learns once how to read your style and can apply it to all your visuals.

- **Focus on the Message**:  
  Before adding elements, ask: “What’s the key takeaway?” If your plot aims to show that a particular species has a longer petal length, highlight that difference. Draw the viewer’s eye with colours or annotations. Each design decision should serve the main story.

*These principles transform a raw plot into a narrative device, helping the audience understand and remember the message.*[^1]

---

#### Choosing Appropriate Visual Encodings

- **Position and Length**:  
  Humans perceive differences in length and position more accurately than angle or area. Whenever possible, choose encodings that leverage these strengths. Bar lengths or point positions along an axis are interpreted easily.

- **Colour and Shape**:  
  Colour is great for categorisation but be mindful of colourblind-friendly palettes. Use shape or linetype as secondary encodings. Reserve bright colours for highlighting important features and more neutral tones for background elements.

- **Using Space Wisely**:  
  Consider aspect ratio. If you have time on the x-axis and something else on the y, ensure the aspect ratio doesn’t distort patterns. In some cases, a square plot may better reflect the true relationship than a wide or tall plot.

---

#### Annotations and Highlights

*Annotations help tell your story directly on the plot:*

- Add lines or arrows to highlight key thresholds (e.g., $$y=0$$ line or a reference value).
- Place text labels near points of interest. Consider using `ggrepel::geom_text_repel()` for neat label placement.
- Use subtle shading or `geom_rect()` to highlight certain ranges, like a period of economic recession on a time series plot.

*These visual cues act like a tour guide, pointing out landmarks in the data landscape.*

---

#### Applying Themes and Styles Thoughtfully

- **Minimalistic Themes**:  
  A theme like `theme_minimal()` or `theme_bw()` often works well in professional reports. They produce clean visuals that print well and look good on screens.

- **Branded Themes**:  
  For a corporate setting, you might align colours and fonts with a brand’s style guide. This ensures visual consistency across all outputs, building trust and recognisability.

- **Grid and Axis Decisions**:  
  Consider whether grid lines help or hinder. In some plots, a horizontal grid may help compare values easily, while vertical lines may distract. Turn off unnecessary lines with `theme()` customisations.

---

#### Example: Refining a Plot for Clarity

*Let’s say we have a scatterplot of `Sepal.Length` vs. `Petal.Length` for the iris dataset. Initially, we just plotted points. Now we’ll apply best practices:*

1. **Identify the Key Message**: Suppose we want to highlight that `Virginica` has generally larger petals than `Setosa`.
2. **Highlight Differences**: Use distinct colours and maybe annotate means of each species.
3. **Clean the Theme**: Choose a minimal theme, add a subtitle explaining what to look for, and provide units.

\\`\\`\\`r
iris_data <- data.table::as.data.table(datasets::iris)

# Compute species means
species_means <- iris_data[ , .(mean_petal_length = mean(Petal.Length)), by = Species]

p <- ggplot2::ggplot(data = iris_data, ggplot2::aes(x = Sepal.Length, y = Petal.Length, colour = Species)) +
  ggplot2::geom_point(alpha = 0.7) +
  ggplot2::geom_hline(yintercept = species_means[Species == "virginica"]$mean_petal_length, 
                      linetype = "dashed", colour = "red") +
  ggplot2::geom_text(ggplot2::aes(x = 5, 
                                  y = species_means[Species == "virginica"]$mean_petal_length + 0.1, 
                                  label = "Virginica Mean Petal Length"),
                     colour = "red") +
  ggplot2::labs(
    title = "Comparing Petal Length Across Iris Species",
    subtitle = "Notice how Virginica tends to have longer petals, indicated by the red dashed line",
    x = "Sepal Length (cm)",
    y = "Petal Length (cm)",
    colour = "Species"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(face = "bold", size = 14),
    plot.subtitle = ggplot2::element_text(size = 12),
    axis.title = ggplot2::element_text(size = 12),
    axis.text = ggplot2::element_text(size = 10),
    legend.text = ggplot2::element_text(size = 10),
    legend.position = "right"
  )

p
\\`\\`\\`

*Now we have a clear title, a subtitle guiding the interpretation, a dashed line showing Virginica’s mean, and a neatly chosen theme. The message “Virginica generally has longer petals” stands out.*

---

#### Use Cases and Audience Consideration

*Always consider who will see your plot and the medium of delivery:*

- **Internal Teams**: More detailed legends, less focus on aesthetic. They value the raw detail.
- **Public Presentations**: Clearer titles, fewer data points, more annotations. A story-driven approach.
- **Academic Publications**: Consistent formatting, proper units, and references to methods.

*Understanding your audience ensures you choose the right level of detail and the right balance between aesthetics and raw data display.*

---

#### Mathematical Underpinnings

*While visual best practices are less about maths and more about human perception, remember that many aspects (like aspect ratio, scale transformations) rely on mathematical transformations. The core idea is to optimise how humans parse patterns. For example, a linear scale might distort the perception of multiplicative changes, so a log scale is chosen to represent $$y = \log(x)$$. Good practices align these transformations and aesthetics with how our brains interpret shapes and positions.*

---

#### Refinement is Key

*Rarely is your first plot the best one. Iteration helps:  
- Try a different colour palette.  
- Add or remove grid lines and legends.  
- Show it to a colleague and see if they “get it”.*

*Refinement transforms a rough draft into a final masterpiece ready for publication or presentation.*

---

#### Next Steps

*Now that you’ve learned how to communicate results effectively through visual best practices, you’re well-equipped to transform any data story into a clear, engaging, and memorable graphic. In future chapters, we’ll integrate these principles with our broader analytical workflow, ensuring every plot you produce helps illuminate your data’s secrets.*

[^1]: Resources like "The Visual Display of Quantitative Information" by Edward Tufte or "Storytelling with Data" by Cole Nussbaumer Knaflic provide deeper insights into effective data visualisation principles.  