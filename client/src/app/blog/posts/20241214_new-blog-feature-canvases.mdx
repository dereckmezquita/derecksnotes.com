---
title: "Canvases a canvas for creativity"
blurb: "L'extase de l'extase"
coverImage: 205
author: "Dereck Mezquita"
date: 2024-12-14
tags: [programming, javascript, mathematics, blog, website, next, react, nextjs, reactjs]
published: true
comments: true
---

In this article, we explore the power of integrating HTML canvases into our blog posts. Each demonstration is a live rendering powered by JavaScript, illustrating not just beautiful patterns but also fundamental mathematical principles. The new website feature lets us embed custom code and produce dynamic figures on the fly—ideal for bringing complex ideas to life.

We'll delve into the mathematics behind golden spirals, fractal sets, and parametric curves. Along the way, we'll discuss the programming strategies that implement these visualisations and show how combining mathematics with code can produce stunning results.

## The Golden Spiral: A Visualisation of the Divine Proportion

The golden ratio, **φ ≈ 1.618**, is a mathematical constant that appears in art, nature, and geometry. One captivating manifestation is the **golden spiral**, generated by a logarithmic curve that grows outward proportionally.

A simplified version of the golden spiral can be represented in polar coordinates as:

$$
r(\theta) = a \cdot \phi^{\frac{\theta}{\pi/2}}
$$

where $ \phi $ is the golden ratio and $ a $ is a scale factor. We convert these $(r,\theta)$ values to Cartesian coordinates to draw the curve. Programmatically, we step through angles, compute radii, and trace out the spiral on the canvas.

<CanvasWithJs 
    code={`
        // Fill entire canvas with white
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function getGoldenRatio() {
            return (1 + Math.sqrt(5)) / 2;
        }

        function polarToCartesian(r, theta) {
            return {
                x: r * Math.cos(theta),
                y: r * Math.sin(theta)
            };
        }

        function drawGoldenSpiral(ctx, centerX, centerY, startTheta, endTheta, a) {
            const phi = getGoldenRatio();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.beginPath();

            let startR = a * Math.pow(phi, (startTheta / (Math.PI / 2)));
            let startPoint = polarToCartesian(startR, startTheta);
            ctx.moveTo(centerX + startPoint.x, centerY + startPoint.y);

            const step = 0.01;
            for (let theta = startTheta; theta <= endTheta; theta += step) {
                const r = a * Math.pow(phi, (theta / (Math.PI / 2)));
                const point = polarToCartesian(r, theta);
                ctx.lineTo(centerX + point.x, centerY + point.y);
            }

            ctx.stroke();
        }

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const startTheta = -2 * Math.PI;
        const endTheta = 4 * Math.PI;
        const a = 5;
        drawGoldenSpiral(ctx, centerX, centerY, startTheta, endTheta, a);
    `}
    width={500}
    height={400}
/>

## Sierpinski's Triangle: Recursive Geometry in Action

The **Sierpinski triangle** is a fractal formed by recursively removing the central triangle from a subdivided larger one. Its fractal dimension $ D $ is:

$$
D = \frac{\ln(3)}{\ln(2)} \approx 1.585
$$

As the recursion deepens, the pattern reveals infinite self-similarity. Programmatically, we use recursion: at each step, we subdivide and remove parts of the figure until a certain depth is reached.

<CanvasWithJs code={`
    // Fill the canvas with white
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    function drawTriangle(ctx, x1, y1, x2, y2, x3, y3, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        ctx.fill();
    }

    function sierpinski(ctx, x1, y1, x2, y2, x3, y3, depth) {
        if (depth === 0) {
            drawTriangle(ctx, x1, y1, x2, y2, x3, y3, '#000000');
            return;
        }

        const x12 = (x1 + x2) / 2;
        const y12 = (y1 + y2) / 2;
        const x23 = (x2 + x3) / 2;
        const y23 = (y2 + y3) / 2;
        const x31 = (x3 + x1) / 2;
        const y31 = (y3 + y1) / 2;

        sierpinski(ctx, x1, y1, x12, y12, x31, y31, depth - 1);
        sierpinski(ctx, x12, y12, x2, y2, x23, y23, depth - 1);
        sierpinski(ctx, x31, y31, x23, y23, x3, y3, depth - 1);
    }

    const width = canvas.width;
    const height = canvas.height;
    const x1 = width / 2;
    const y1 = 0;
    const x2 = 0;
    const y2 = height;
    const x3 = width;
    const y3 = height;
    const depth = 6;
    sierpinski(ctx, x1, y1, x2, y2, x3, y3, depth);
`} width={400} height={300} />

## The Koch Snowflake: Infinite Perimeter, Finite Area

The **Koch Snowflake** starts with an equilateral triangle and, at each iteration, transforms each line segment. Its fractal dimension is:

$$
D = \frac{\ln(4)}{\ln(3)} \approx 1.2619
$$

The perimeter grows without bound, yet the area converges. Our code recursively subdivides each line segment, introducing a protrusion to form the characteristic "flake" shape.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;

    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    function koch(ctx, x1, y1, x2, y2, depth) {
        if (depth === 0) {
            drawLine(ctx, x1, y1, x2, y2);
            return;
        }

        const dx = x2 - x1;
        const dy = y2 - y1;
        const xA = x1 + dx / 3;
        const yA = y1 + dy / 3;
        const xB = x1 + 2 * dx / 3;
        const yB = y1 + 2 * dy / 3;

        const angle = Math.PI / 3; 
        const mx = xA + (dx/3)*Math.cos(angle) - (dy/3)*Math.sin(angle);
        const my = yA + (dx/3)*Math.sin(angle) + (dy/3)*Math.cos(angle);

        koch(ctx, x1, y1, xA, yA, depth - 1);
        koch(ctx, xA, yA, mx, my, depth - 1);
        koch(ctx, mx, my, xB, yB, depth - 1);
        koch(ctx, xB, yB, x2, y2, depth - 1);
    }

    const width = canvas.width;
    const height = canvas.height;
    const size = Math.min(width, height) * 0.7;
    const xCenter = width / 2;
    const yCenter = height / 2;

    const x1 = xCenter - size / 2;
    const y1 = yCenter + size / (2 * Math.sqrt(3));
    const x2 = xCenter + size / 2;
    const y2 = y1;
    const x3 = xCenter;
    const y3 = yCenter - size / Math.sqrt(3);

    const depth = 4;
    koch(ctx, x1, y1, x2, y2, depth);
    koch(ctx, x2, y2, x3, y3, depth);
    koch(ctx, x3, y3, x1, y1, depth);
`} width={400} height={300} />

## The Fractal Tree: Self-Similarity in Nature's Architecture

Fractal trees mirror patterns found in nature. By repeatedly branching at certain angles and applying a length scale factor, we get a self-similar structure. Each branch reduces to a smaller copy of the whole, reflecting the fractal principle of self-similarity.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;

    function drawBranch(ctx, x, y, length, angle, depth, branchWidth) {
        if (depth === 0) return;

        ctx.lineWidth = branchWidth;
        ctx.beginPath();
        ctx.moveTo(x, y);

        const x2 = x + length * Math.cos(angle);
        const y2 = y + length * Math.sin(angle);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        const newLength = length * 0.7;
        const newDepth = depth - 1;
        const newBranchWidth = branchWidth * 0.7;

        drawBranch(ctx, x2, y2, newLength, angle + Math.PI/4, newDepth, newBranchWidth);
        drawBranch(ctx, x2, y2, newLength, angle - Math.PI/4, newDepth, newBranchWidth);
    }

    const centerX = canvas.width / 2;
    const bottomY = canvas.height;
    drawBranch(ctx, centerX, bottomY, 60, -Math.PI/2, 8, 6);
`} width={300} height={400} />

## The Barnsley Fern: Chaos, Probability, and a Leaf Pattern

The **Barnsley Fern** employs four linear transformations chosen with certain probabilities. Despite the randomness, the points converge into a realistic fern shape. The transformations can be described as:

$$
\begin{aligned}
f_1(x,y) &= (0,0.16y) \\
f_2(x,y) &= (0.85x + 0.04y,\; -0.04x + 0.85y + 1.6) \\
f_3(x,y) &= (0.20x - 0.26y,\; 0.23x + 0.22y + 1.6) \\
f_4(x,y) &= (-0.15x + 0.28y,\; 0.26x + 0.24y + 0.44)
\end{aligned}
$$

Applying these transformations iteratively results in the fractal fern pattern.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#000000';

    let x = 0;
    let y = 0;
    const iterations = 20000;
    for (let i = 0; i < iterations; i++) {
        const r = Math.random();
        let xNext, yNext;

        if (r < 0.01) {
            xNext = 0;
            yNext = 0.16 * y;
        } else if (r < 0.86) {
            xNext = 0.85 * x + 0.04 * y;
            yNext = -0.04 * x + 0.85 * y + 1.6;
        } else if (r < 0.93) {
            xNext = 0.20 * x - 0.26 * y;
            yNext = 0.23 * x + 0.22 * y + 1.6;
        } else {
            xNext = -0.15 * x + 0.28 * y;
            yNext = 0.26 * x + 0.24 * y + 0.44;
        }

        x = xNext;
        y = yNext;

        const px = canvas.width / 2 + x * canvas.height / 11;
        const py = canvas.height - y * canvas.height / 11;
        ctx.fillRect(px, py, 1, 1);
    }
`} width={400} height={300} />

## The Dragon Curve: Folding a Line into Complexity

The **Dragon Curve** emerges from a simple string rewriting system (an L-system). By repeatedly replacing characters $F$ and $G$ with patterns like $F \to F+G$ and $G \to F-G$, and interpreting $+$ and $-$ as turns, we produce a fractal curve of remarkable complexity.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';

    let sequence = 'F';
    const iterations = 10;
    for (let i = 0; i < iterations; i++) {
        let next = '';
        for (const ch of sequence) {
            if (ch === 'F') {
                next += 'F+G';
            } else if (ch === 'G') {
                next += 'F-G';
            } else {
                next += ch;
            }
        }
        sequence = next;
    }

    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let angle = 0;
    const step = 5;

    ctx.beginPath();
    ctx.moveTo(x, y);

    for (const ch of sequence) {
        if (ch === 'F' || ch === 'G') {
            x += Math.cos(angle) * step;
            y += Math.sin(angle) * step;
            ctx.lineTo(x, y);
        } else if (ch === '+') {
            angle += Math.PI / 2; 
        } else if (ch === '-') {
            angle -= Math.PI / 2; 
        }
    }

    ctx.stroke();
`} width={400} height={300} />

## The Rose (Rhodonea) Curve: Petals of Pure Mathematics

A **Rose Curve** can be defined as:

$$
r(\theta) = \cos(k\theta) \quad \text{or} \quad r(\theta) = \sin(k\theta)
$$

Adjusting $k$ changes the number of petals. We map this polar equation into Cartesian coordinates and draw a smooth, petal-like pattern.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();

    const k = 5; 
    const radius = Math.min(canvas.width, canvas.height) / 2 * 0.8;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const steps = 2000;
    for (let i = 0; i <= steps; i++) {
        const theta = (i / steps) * 2 * Math.PI;
        const r = radius * Math.cos(k * theta);
        const x = centerX + r * Math.cos(theta);
        const y = centerY + r * Math.sin(theta);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }

    ctx.stroke();
`} width={400} height={300} />
