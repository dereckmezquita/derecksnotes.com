---
title: "New blog feature: canvases"
blurb: "Circus bitch world"
coverImage: 205
author: "Dereck Mezquita"
date: 2024-12-14
tags: [programming, javascript, mathematics, blog, website, next, react, nextjs, reactjs]
published: true
comments: true
---

## Golden Spiral Demo (Smaller Canvas)

<CanvasWithJs 
    code={`
        // Fill entire canvas with white
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function getGoldenRatio() {
            return (1 + Math.sqrt(5)) / 2;
        }

        function polarToCartesian(r, theta) {
            return {
                x: r * Math.cos(theta),
                y: r * Math.sin(theta)
            };
        }

        function drawGoldenSpiral(ctx, centerX, centerY, startTheta, endTheta, a) {
            const phi = getGoldenRatio();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.beginPath();

            let startR = a * Math.pow(phi, (startTheta / (Math.PI / 2)));
            let startPoint = polarToCartesian(startR, startTheta);
            ctx.moveTo(centerX + startPoint.x, centerY + startPoint.y);

            const step = 0.01;
            for (let theta = startTheta; theta <= endTheta; theta += step) {
                const r = a * Math.pow(phi, (theta / (Math.PI / 2)));
                const point = polarToCartesian(r, theta);
                ctx.lineTo(centerX + point.x, centerY + point.y);
            }

            ctx.stroke();
        }

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const startTheta = -2 * Math.PI;
        const endTheta = 4 * Math.PI;
        const a = 5;
        drawGoldenSpiral(ctx, centerX, centerY, startTheta, endTheta, a);
    `}
    width={500}
    height={400}
/>

## Fractal Demo: Sierpinski Triangle

<CanvasWithJs code={`
    // Fill the canvas with white
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    function drawTriangle(ctx, x1, y1, x2, y2, x3, y3, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        ctx.fill();
    }

    function sierpinski(ctx, x1, y1, x2, y2, x3, y3, depth) {
        if (depth === 0) {
            drawTriangle(ctx, x1, y1, x2, y2, x3, y3, '#000000');
            return;
        }

        const x12 = (x1 + x2) / 2;
        const y12 = (y1 + y2) / 2;
        const x23 = (x2 + x3) / 2;
        const y23 = (y2 + y3) / 2;
        const x31 = (x3 + x1) / 2;
        const y31 = (y3 + y1) / 2;

        sierpinski(ctx, x1, y1, x12, y12, x31, y31, depth - 1);
        sierpinski(ctx, x12, y12, x2, y2, x23, y23, depth - 1);
        sierpinski(ctx, x31, y31, x23, y23, x3, y3, depth - 1);
    }

    const width = canvas.width;
    const height = canvas.height;
    const x1 = width / 2;
    const y1 = 0;
    const x2 = 0;
    const y2 = height;
    const x3 = width;
    const y3 = height;
    const depth = 6;
    sierpinski(ctx, x1, y1, x2, y2, x3, y3, depth);
`} width={400} height={300} />

## Fractal Demo: Koch Snowflake

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;

    function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    function koch(ctx, x1, y1, x2, y2, depth) {
        if (depth === 0) {
            drawLine(ctx, x1, y1, x2, y2);
            return;
        }

        const dx = x2 - x1;
        const dy = y2 - y1;
        const xA = x1 + dx / 3;
        const yA = y1 + dy / 3;
        const xB = x1 + 2 * dx / 3;
        const yB = y1 + 2 * dy / 3;

        const angle = Math.PI / 3; 
        const mx = xA + (dx/3)*Math.cos(angle) - (dy/3)*Math.sin(angle);
        const my = yA + (dx/3)*Math.sin(angle) + (dy/3)*Math.cos(angle);

        koch(ctx, x1, y1, xA, yA, depth - 1);
        koch(ctx, xA, yA, mx, my, depth - 1);
        koch(ctx, mx, my, xB, yB, depth - 1);
        koch(ctx, xB, yB, x2, y2, depth - 1);
    }

    const width = canvas.width;
    const height = canvas.height;
    const size = Math.min(width, height) * 0.7;
    const xCenter = width / 2;
    const yCenter = height / 2;

    const x1 = xCenter - size / 2;
    const y1 = yCenter + size / (2 * Math.sqrt(3));
    const x2 = xCenter + size / 2;
    const y2 = y1;
    const x3 = xCenter;
    const y3 = yCenter - size / Math.sqrt(3);

    const depth = 4;
    koch(ctx, x1, y1, x2, y2, depth);
    koch(ctx, x2, y2, x3, y3, depth);
    koch(ctx, x3, y3, x1, y1, depth);
`} width={400} height={300} />

## Fractal Demo: Fractal Tree (Revised to Fill Canvas)

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;

    function drawBranch(ctx, x, y, length, angle, depth, branchWidth) {
        if (depth === 0) return;

        ctx.lineWidth = branchWidth;
        ctx.beginPath();
        ctx.moveTo(x, y);

        const x2 = x + length * Math.cos(angle);
        const y2 = y + length * Math.sin(angle);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // Branch reduction
        const newLength = length * 0.7;
        const newDepth = depth - 1;
        const newBranchWidth = branchWidth * 0.7;

        // Draw right branch
        drawBranch(ctx, x2, y2, newLength, angle + Math.PI/4, newDepth, newBranchWidth);
        // Draw left branch
        drawBranch(ctx, x2, y2, newLength, angle - Math.PI/4, newDepth, newBranchWidth);
    }

    const centerX = canvas.width / 2;
    const bottomY = canvas.height;
    drawBranch(ctx, centerX, bottomY, 60, -Math.PI/2, 8, 6);
`} width={300} height={400} />


## Barnsley Fern Demo

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#000000';

    let x = 0;
    let y = 0;
    const iterations = 20000;
    for (let i = 0; i < iterations; i++) {
        const r = Math.random();
        let xNext, yNext;

        if (r < 0.01) {
            // Stem transformation
            xNext = 0;
            yNext = 0.16 * y;
        } else if (r < 0.86) {
            // Main frond transformation
            xNext = 0.85 * x + 0.04 * y;
            yNext = -0.04 * x + 0.85 * y + 1.6;
        } else if (r < 0.93) {
            // Left leaf transformation
            xNext = 0.20 * x - 0.26 * y;
            yNext = 0.23 * x + 0.22 * y + 1.6;
        } else {
            // Right leaf transformation
            xNext = -0.15 * x + 0.28 * y;
            yNext = 0.26 * x + 0.24 * y + 0.44;
        }

        x = xNext;
        y = yNext;

        // Scale and center the fern
        const px = canvas.width / 2 + x * canvas.height / 11;
        const py = canvas.height - y * canvas.height / 11;
        ctx.fillRect(px, py, 1, 1);
    }
`} width={400} height={300} />


## Dragon Curve Demo

The Dragon Curve is generated by repeatedly folding a line and flattening it. We’ll generate coordinates iteratively.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';

    // Generate Dragon Curve points using a simple L-system-like expansion
    let sequence = 'F';
    const iterations = 10;
    for (let i = 0; i < iterations; i++) {
        let next = '';
        for (const ch of sequence) {
            if (ch === 'F') {
                next += 'F+G';
            } else if (ch === 'G') {
                next += 'F-G';
            } else {
                next += ch;
            }
        }
        sequence = next;
        // Replace '+' and '-' remain the same
    }

    // We now have a string of F, G, +, - that defines a path
    // Interpret F/G as forward moves, + as turn left 90°, - as turn right 90°
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    let angle = 0;
    const step = 5;

    ctx.beginPath();
    ctx.moveTo(x, y);

    for (const ch of sequence) {
        if (ch === 'F' || ch === 'G') {
            x += Math.cos(angle) * step;
            y += Math.sin(angle) * step;
            ctx.lineTo(x, y);
        } else if (ch === '+') {
            angle += Math.PI / 2; // turn left 90°
        } else if (ch === '-') {
            angle -= Math.PI / 2; // turn right 90°
        }
    }

    ctx.stroke();
`} width={400} height={300} />


## Rose Curve (Rhodonea Curve) Demo

A rose curve is defined by a polar equation r = cos(kθ) or r = sin(kθ) for some integer k. These produce symmetrical petal-like patterns.

<CanvasWithJs code={`
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();

    const k = 5; // number of petals if k is odd, rose has k petals; if even, it has 2k petals.
    const radius = Math.min(canvas.width, canvas.height) / 2 * 0.8;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const steps = 2000;
    for (let i = 0; i <= steps; i++) {
        const theta = (i / steps) * 2 * Math.PI;
        const r = radius * Math.cos(k * theta);
        const x = centerX + r * Math.cos(theta);
        const y = centerY + r * Math.sin(theta);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }

    ctx.stroke();
`} width={400} height={300} />